
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Core Functions &#8212; CaImAn 1.4 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Demos" href="Getting_Started.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Getting_Started.html" title="Demos"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CaImAn 1.4 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="core-functions">
<h1>Core Functions<a class="headerlink" href="#core-functions" title="Permalink to this headline">¶</a></h1>
<p>Functions that are required to operate the package at a basic level</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.CNMF</span></code>(n_processes)</p></td>
<td><p>Source extraction using constrained non-negative matrix factorization.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.CNMF.fit</span></code>(self, …)</p></td>
<td><p>This method uses the cnmf algorithm to find sources in data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID" title="caiman.source_extraction.cnmf.online_cnmf.OnACID"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.online_cnmf.OnACID</span></code></a>([…])</p></td>
<td><p>Source extraction of streaming data using online matrix factorization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online</span></code></a>(…)</p></td>
<td><p>Implements the caiman online algorithm on the list of files fls.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.params.CNMFParams.__init__</span></code>(self)</p></td>
<td><p>Class for setting the processing parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates" title="caiman.source_extraction.cnmf.estimates.Estimates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.estimates.Estimates</span></code></a>([…])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.motion_correction.MotionCorrect" title="caiman.motion_correction.MotionCorrect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.motion_correction.MotionCorrect</span></code></a>(fname)</p></td>
<td><p>class implementing motion correction operations</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct" title="caiman.motion_correction.MotionCorrect.motion_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.motion_correction.MotionCorrect.motion_correct</span></code></a>(self)</p></td>
<td><p>general function for performing all types of motion correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.base.movies.load" title="caiman.base.movies.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.movies.load</span></code></a>(file_name, fr, …)</p></td>
<td><p>load movie from file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.base.movies.movie.play" title="caiman.base.movies.movie.play"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.movies.movie.play</span></code></a>(self, gain[, …])</p></td>
<td><p>Play the movie using opencv</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.base.rois.register_ROIs" title="caiman.base.rois.register_ROIs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.rois.register_ROIs</span></code></a>(A1, A2, dims)</p></td>
<td><p>Register ROIs across different sessions using an intersection over union  metric and the Hungarian algorithm for optimal matching</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.base.rois.register_multisession" title="caiman.base.rois.register_multisession"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.rois.register_multisession</span></code></a>(A, dims)</p></td>
<td><p>Register ROIs across multiple sessions using an intersection over union metric and the Hungarian algorithm for optimal matching.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.utilities.detrend_df_f" title="caiman.source_extraction.cnmf.utilities.detrend_df_f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.utilities.detrend_df_f</span></code></a>(A, …)</p></td>
<td><p>Compute DF/F signal without using the original data.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="movie-handling">
<h2>Movie Handling<a class="headerlink" href="#movie-handling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.base.movies.movie">
<em class="property">class </em><code class="sig-prename descclassname">caiman.base.movies.</code><code class="sig-name descname">movie</code><a class="headerlink" href="#caiman.base.movies.movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a movie. This class subclasses timeseries,
that in turn subclasses ndarray</p>
<p>movie(input_arr, fr=None,start_time=0,file_name=None, meta_data=None)</p>
<dl class="simple">
<dt>Example of usage:</dt><dd><p>input_arr = 3d ndarray
fr=33; # 33 Hz
start_time=0
m=movie(input_arr, start_time=0,fr=33);</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt><dd><p>An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt><dd><p>Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt><dd><p>A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt><dd><p>The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt><dd><p>Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt><dd><p>Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt><dd><p>Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt><dd><p>The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt><dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
<dt><strong>time</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA</span></code>(self, components, batch)</p></td>
<td><p>Iterative Principal Component analysis, see sklearn.decomposition.incremental_pca</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA_denoise</span></code>(self, components, batch)</p></td>
<td><p>Create a denoised version of the movie using only the first ‘components’ components</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA_io</span></code>(self, n_components, fun, max_iter[, tol])</p></td>
<td><p>DO NOT USE STILL UNDER DEVELOPMENT</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA_stICA</span></code>(self, componentsPCA, …)</p></td>
<td><p>Compute PCA + ICA a la Mukamel 2009.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">NonnegativeMatrixFactorization</span></code>(self, …[, tol])</p></td>
<td><p>See documentation for scikit-learn NMF</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis, out, keepdims])</p></td>
<td><p>Returns True if all elements evaluate to True.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis, out, keepdims])</p></td>
<td><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_shifts</span></code>(self, shifts[, interpolation, …])</p></td>
<td><p>Apply precomputed shifts to a movie, using subpixels adjustment (cv2.INTER_CUBIC function)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis, out])</p></td>
<td><p>Return indices of the maximum values along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis, out])</p></td>
<td><p>Return indices of the minimum values along the given axis of <cite>a</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Returns the indices that would partition this array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis, kind, order])</p></td>
<td><p>Returns the indices that would sort this array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[, order, casting, subok, copy])</p></td>
<td><p>Copy of the array, cast to a specified type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bilateral_blur_2D</span></code>(self, diameter, sigmaColor)</p></td>
<td><p>performs bilateral filtering on each frame.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin_median</span></code>(self[, window])</p></td>
<td><p>compute median of 3D array in along axis o by binning values</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>([inplace])</p></td>
<td><p>Swap the bytes of the array elements</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[, out, mode])</p></td>
<td><p>Use an index array to construct a new array from a set of choices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min, max, out])</p></td>
<td><p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[, axis, out])</p></td>
<td><p>Return selected slices of this array along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.base.movies.movie.computeDFF" title="caiman.base.movies.movie.computeDFF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">computeDFF</span></code></a>(self, secsWindow, quantilMin, …)</p></td>
<td><p>compute the DFF of the movie or remove baseline</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</p></td>
<td><p>Complex-conjugate all elements.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</p></td>
<td><p>Return the complex conjugate, element-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</p></td>
<td><p>Return a copy of the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code>(self[, crop_top, crop_bottom, …])</p></td>
<td><p>Crop movie</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative product of the elements along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative sum of the elements along the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">debleach</span></code>(self)</p></td>
<td><p>Debleach by fiting a model to the median intensity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset, axis1, axis2])</p></td>
<td><p>Return specified diagonals.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(b[, out])</p></td>
<td><p>Dot product of two arrays.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</p></td>
<td><p>Dump a pickle of the array to the specified file.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</p></td>
<td><p>Returns the pickle of the array as a string.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_shifts</span></code>(self, max_shift_w, max_shift_h)</p></td>
<td><p>Performs motion correction using the opencv matchtemplate function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_traces_from_masks</span></code>(self, masks)</p></td>
<td><p>Args:</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</p></td>
<td><p>Fill the array with a scalar value.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</p></td>
<td><p>Return a copy of the array collapsed into one dimension.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian_blur_2D</span></code>(self[, kernel_size_x, …])</p></td>
<td><p>Compute gaussian blut in 2D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[, offset])</p></td>
<td><p>Returns a field of the given array as a certain type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">guided_filter_blur_2D</span></code>(self, guide_filter, radius)</p></td>
<td><p>performs guided filtering on each frame.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</p></td>
<td><p>Copy an element of an array to a standard Python scalar and return it.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</p></td>
<td><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_correlations</span></code>(self, eight_neighbours, …)</p></td>
<td><p>Computes the correlation image for the input dataset Y</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code>([axis, out, keepdims])</p></td>
<td><p>Return the maximum along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>([axis, dtype, out, keepdims])</p></td>
<td><p>Returns the average of the array elements along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">median_blur_2D</span></code>(self[, kernel_size])</p></td>
<td><p>Compute gaussian blut in 2D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code>([axis, out, keepdims])</p></td>
<td><p>Return the minimum along a given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct</span></code>(self[, max_shift_w, …])</p></td>
<td><p>Extract shifts and motion corrected movie automatically,</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</p></td>
<td><p>Return the array with the same data viewed with a different byte order.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</p></td>
<td><p>Return the indices of the elements that are non-zero.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">online_NMF</span></code>(self, n_components, method, …)</p></td>
<td><p>Method performing online matrix factorization and using the spams</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_FOV_KMeans</span></code>(self, tradeoff_weight, …)</p></td>
<td><p>Partition the FOV in clusters that are grouping pixels close in space and in mutual correlation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.base.movies.movie.play" title="caiman.base.movies.movie.play"><code class="xref py py-obj docutils literal notranslate"><span class="pre">play</span></code></a>(self, gain[, fr, magnification, …])</p></td>
<td><p>Play the movie using opencv</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>([axis, dtype, out, keepdims])</p></td>
<td><p>Return the product of the array elements over the given axis</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code>([axis, out, keepdims])</p></td>
<td><p>Peak to peak (maximum - minimum) value along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices, values[, mode])</p></td>
<td><p>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</p></td>
<td><p>Return a flattened array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[, axis])</p></td>
<td><p>Repeat elements of an array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[, order])</p></td>
<td><p>Returns an array containing the same data with a new shape.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.base.movies.movie.resize" title="caiman.base.movies.movie.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a>(new_shape[, refcheck])</p></td>
<td><p>Change shape and size of array in-place.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals, out])</p></td>
<td><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code>(self, file_name[, to32, order, imagej, …])</p></td>
<td><p>Save the timeseries in single precision.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[, side, sorter])</p></td>
<td><p>Find indices where elements of v should be inserted in a to maintain order.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val, dtype[, offset])</p></td>
<td><p>Put a value into a specified place in a field defined by a data-type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write, align, uic])</p></td>
<td><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis, kind, order])</p></td>
<td><p>Sort an array, in-place.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</p></td>
<td><p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>([axis, dtype, out, ddof, keepdims])</p></td>
<td><p>Returns the standard deviation of the array elements along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code>([axis, dtype, out, keepdims])</p></td>
<td><p>Return the sum of the array elements over the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1, axis2)</p></td>
<td><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[, axis, out, mode])</p></td>
<td><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[, sep, format])</p></td>
<td><p>Write array to a file as text or binary (default).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</p></td>
<td><p>Return the array as a (possibly nested) list.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset, axis1, axis2, dtype, out])</p></td>
<td><p>Return the sum along diagonals of the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</p></td>
<td><p>Returns a view of the array with axes transposed.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>([axis, dtype, out, ddof, keepdims])</p></td>
<td><p>Returns the variance of the array elements, along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype, type])</p></td>
<td><p>New view of array with the same data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">zproject</span></code>(self[, method, cmap, aspect])</p></td>
<td><p>Compute and plot projection across time:</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>apply_shifts_online</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>calc_min</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>to_2D</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.base.movies.movie.play">
<code class="sig-prename descclassname">movie.</code><code class="sig-name descname">play</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">gain:float=1</em>, <em class="sig-param">fr=None</em>, <em class="sig-param">magnification=1</em>, <em class="sig-param">offset=0</em>, <em class="sig-param">interpolation=1</em>, <em class="sig-param">backend:str='opencv'</em>, <em class="sig-param">do_loop:bool=False</em>, <em class="sig-param">bord_px=None</em>, <em class="sig-param">q_max=100</em>, <em class="sig-param">q_min=0</em>, <em class="sig-param">plot_text:bool=False</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#caiman.base.movies.movie.play" title="Permalink to this definition">¶</a></dt>
<dd><p>Play the movie using opencv</p>
<dl>
<dt>Args:</dt><dd><p>gain: adjust movie brightness</p>
<p>fr: framerate, playing speed if different from original (inter frame interval in seconds)</p>
<p>magnification: (undocumented)</p>
<p>offset: (undocumented)</p>
<p>interpolation: (undocumented)</p>
<p>backend: ‘pylab’ or ‘opencv’, the latter much faster</p>
<p>do_loop: Whether to loop the video</p>
<p>bord_px: (undocumented)</p>
<p>q_max, q_min: (undocumented)</p>
<p>plot_text: (undocumented)</p>
</dd>
<dt>Raises:</dt><dd><p>Exception ‘Unknown backend!’</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.base.movies.movie.resize">
<code class="sig-prename descclassname">movie.</code><code class="sig-name descname">resize</code><span class="sig-paren">(</span><em class="sig-param">new_shape</em>, <em class="sig-param">refcheck=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.movies.movie.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change shape and size of array in-place.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>new_shape</strong><span class="classifier">tuple of ints, or <cite>n</cite> ints</span></dt><dd><p>Shape of resized array.</p>
</dd>
<dt><strong>refcheck</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, reference count will not be checked. Default is True.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>a</cite> does not own its own data or references or views to it exist,
and the data memory must be changed.
PyPy only: will always raise if the data memory must be changed, since
there is no reliable way to determine if references or views to it
exist.</p>
</dd>
<dt>SystemError</dt><dd><p>If the <cite>order</cite> keyword argument is specified. This behaviour is a
bug in NumPy.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#caiman.base.movies.movie.resize" title="caiman.base.movies.movie.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a></dt><dd><p>Return a new array with the specified shape.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This reallocates space for the data area if necessary.</p>
<p>Only contiguous arrays (data elements consecutive in memory) can be
resized.</p>
<p>The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
<cite>refcheck</cite> to False.</p>
<p class="rubric">Examples</p>
<p>Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [1]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [2]])</span>
</pre></div>
</div>
<p>Enlarging an array: as above, but missing entries are filled with zeros:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># new_shape parameter doesn&#39;t have to be a tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 0]])</span>
</pre></div>
</div>
<p>Referencing an array prevents resizing…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot resize an array that has been referenced ...</span>
</pre></div>
</div>
<p>Unless <cite>refcheck</cite> is False:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="caiman.base.movies.movie.computeDFF">
<code class="sig-prename descclassname">movie.</code><code class="sig-name descname">computeDFF</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">secsWindow:int=5</em>, <em class="sig-param">quantilMin:int=8</em>, <em class="sig-param">method:str='only_baseline'</em>, <em class="sig-param">order:str='F'</em><span class="sig-paren">)</span> &#x2192; Tuple[Any, Any]<a class="headerlink" href="#caiman.base.movies.movie.computeDFF" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the DFF of the movie or remove baseline</p>
<p>In order to compute the baseline frames are binned according to the window length parameter
and then the intermediate values are interpolated.</p>
<dl>
<dt>Args:</dt><dd><p>secsWindow: length of the windows used to compute the quantile</p>
<p>quantilMin : value of the quantile</p>
<p>method=’only_baseline’,’delta_f_over_f’,’delta_f_over_sqrt_f’</p>
</dd>
<dt>Returns:</dt><dd><p>self: DF or DF/F or DF/sqrt(F) movies</p>
<p>movBL=baseline movie</p>
</dd>
<dt>Raises:</dt><dd><p>Exception ‘Unknown method’</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.movies.load">
<code class="sig-prename descclassname">caiman.base.movies.</code><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">fr:float=30</em>, <em class="sig-param">start_time:float=0</em>, <em class="sig-param">meta_data:Dict=None</em>, <em class="sig-param">subindices=None</em>, <em class="sig-param">shape:Tuple[int</em>, <em class="sig-param">int]=None</em>, <em class="sig-param">var_name_hdf5:str='mov'</em>, <em class="sig-param">in_memory:bool=False</em>, <em class="sig-param">is_behavior:bool=False</em>, <em class="sig-param">bottom=0</em>, <em class="sig-param">top=0</em>, <em class="sig-param">left=0</em>, <em class="sig-param">right=0</em>, <em class="sig-param">channel=None</em>, <em class="sig-param">outtype=&lt;class 'numpy.float32'&gt;</em><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#caiman.base.movies.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load movie from file. Supports a variety of formats. tif, hdf5, npy and memory mapped. Matlab is experimental.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name: string</dt><dd><p>name of file. Possible extensions are tif, avi, npy, (npz and hdf5 are usable only if saved by calblitz)</p>
</dd>
<dt>fr: float</dt><dd><p>frame rate</p>
</dd>
<dt>start_time: float</dt><dd><p>initial time for frame 1</p>
</dd>
<dt>meta_data: dict</dt><dd><p>dictionary containing meta information about the movie</p>
</dd>
<dt>subindices: iterable indexes</dt><dd><p>for loading only portion of the movie</p>
</dd>
<dt>shape: tuple of two values</dt><dd><p>dimension of the movie along x and y if loading from a two dimensional numpy array</p>
</dd>
<dt>var_name_hdf5: str</dt><dd><p>if loading from hdf5 name of the variable to load</p>
</dd>
</dl>
<p>in_memory: (undocumented)</p>
<p>is_behavior: (undocumented)</p>
<p>bottom,top,left,right: (undocumented)</p>
<p>channel: (undocumented)</p>
<p>outtype: The data type for the movie</p>
</dd>
<dt>Returns:</dt><dd><p>mov: caiman.movie</p>
</dd>
<dt>Raises:</dt><dd><p>Exception ‘Subindices not implemented’</p>
<p>Exception ‘Subindices not implemented’</p>
<p>Exception ‘sima module unavailable’</p>
<p>Exception ‘Unknown file type’</p>
<p>Exception ‘File not found!’</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.movies.load_movie_chain">
<code class="sig-prename descclassname">caiman.base.movies.</code><code class="sig-name descname">load_movie_chain</code><span class="sig-paren">(</span><em class="sig-param">file_list:List[str], fr:float=30, start_time=0, meta_data=None, subindices=None, var_name_hdf5:str='mov', bottom=0, top=0, left=0, right=0, z_top=0, z_bottom=0, is3D:bool=False, channel=None, outtype=&lt;class 'numpy.float32'&gt;</em><span class="sig-paren">)</span> &#x2192; Any<a class="headerlink" href="#caiman.base.movies.load_movie_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>load movies from list of file names</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>file_list: list</dt><dd><p>file names in string format</p>
</dd>
</dl>
<p>the other parameters as in load_movie except</p>
<dl class="simple">
<dt>bottom, top, left, right, z_top, z_bottom<span class="classifier">int</span></dt><dd><p>to load only portion of the field of view</p>
</dd>
<dt>is3D<span class="classifier">bool</span></dt><dd><p>flag for 3d data (adds a fourth dimension)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>movie: movie</dt><dd><p>movie corresponding to the concatenation og the input files</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="timeseries-handling">
<h2>Timeseries Handling<a class="headerlink" href="#timeseries-handling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.base.timeseries.timeseries">
<em class="property">class </em><code class="sig-prename descclassname">caiman.base.timeseries.</code><code class="sig-name descname">timeseries</code><a class="headerlink" href="#caiman.base.timeseries.timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt><dd><p>An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt><dd><p>Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt><dd><p>A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt><dd><p>The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt><dd><p>Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt><dd><p>Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt><dd><p>Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt><dd><p>The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt><dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
<dt><strong>time</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis, out, keepdims])</p></td>
<td><p>Returns True if all elements evaluate to True.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis, out, keepdims])</p></td>
<td><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis, out])</p></td>
<td><p>Return indices of the maximum values along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis, out])</p></td>
<td><p>Return indices of the minimum values along the given axis of <cite>a</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Returns the indices that would partition this array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis, kind, order])</p></td>
<td><p>Returns the indices that would sort this array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[, order, casting, subok, copy])</p></td>
<td><p>Copy of the array, cast to a specified type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>([inplace])</p></td>
<td><p>Swap the bytes of the array elements</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[, out, mode])</p></td>
<td><p>Use an index array to construct a new array from a set of choices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min, max, out])</p></td>
<td><p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[, axis, out])</p></td>
<td><p>Return selected slices of this array along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</p></td>
<td><p>Complex-conjugate all elements.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</p></td>
<td><p>Return the complex conjugate, element-wise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</p></td>
<td><p>Return a copy of the array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative product of the elements along the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code>([axis, dtype, out])</p></td>
<td><p>Return the cumulative sum of the elements along the given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset, axis1, axis2])</p></td>
<td><p>Return specified diagonals.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(b[, out])</p></td>
<td><p>Dot product of two arrays.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</p></td>
<td><p>Dump a pickle of the array to the specified file.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</p></td>
<td><p>Returns the pickle of the array as a string.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</p></td>
<td><p>Fill the array with a scalar value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</p></td>
<td><p>Return a copy of the array collapsed into one dimension.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[, offset])</p></td>
<td><p>Returns a field of the given array as a certain type.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</p></td>
<td><p>Copy an element of an array to a standard Python scalar and return it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</p></td>
<td><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code>([axis, out, keepdims])</p></td>
<td><p>Return the maximum along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>([axis, dtype, out, keepdims])</p></td>
<td><p>Returns the average of the array elements along given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code>([axis, out, keepdims])</p></td>
<td><p>Return the minimum along a given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</p></td>
<td><p>Return the array with the same data viewed with a different byte order.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</p></td>
<td><p>Return the indices of the elements that are non-zero.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[, axis, kind, order])</p></td>
<td><p>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>([axis, dtype, out, keepdims])</p></td>
<td><p>Return the product of the array elements over the given axis</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code>([axis, out, keepdims])</p></td>
<td><p>Peak to peak (maximum - minimum) value along a given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices, values[, mode])</p></td>
<td><p>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</p></td>
<td><p>Return a flattened array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[, axis])</p></td>
<td><p>Repeat elements of an array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[, order])</p></td>
<td><p>Returns an array containing the same data with a new shape.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code>(new_shape[, refcheck])</p></td>
<td><p>Change shape and size of array in-place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals, out])</p></td>
<td><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.base.timeseries.timeseries.save" title="caiman.base.timeseries.timeseries.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(self, file_name[, to32, order, imagej, …])</p></td>
<td><p>Save the timeseries in single precision.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[, side, sorter])</p></td>
<td><p>Find indices where elements of v should be inserted in a to maintain order.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val, dtype[, offset])</p></td>
<td><p>Put a value into a specified place in a field defined by a data-type.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write, align, uic])</p></td>
<td><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis, kind, order])</p></td>
<td><p>Sort an array, in-place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</p></td>
<td><p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>([axis, dtype, out, ddof, keepdims])</p></td>
<td><p>Returns the standard deviation of the array elements along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code>([axis, dtype, out, keepdims])</p></td>
<td><p>Return the sum of the array elements over the given axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1, axis2)</p></td>
<td><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[, axis, out, mode])</p></td>
<td><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[, sep, format])</p></td>
<td><p>Write array to a file as text or binary (default).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</p></td>
<td><p>Return the array as a (possibly nested) list.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</p></td>
<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset, axis1, axis2, dtype, out])</p></td>
<td><p>Return the sum along diagonals of the array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</p></td>
<td><p>Returns a view of the array with axes transposed.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>([axis, dtype, out, ddof, keepdims])</p></td>
<td><p>Returns the variance of the array elements, along given axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype, type])</p></td>
<td><p>New view of array with the same data.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.base.timeseries.timeseries.save">
<code class="sig-prename descclassname">timeseries.</code><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">file_name</em>, <em class="sig-param">to32=True</em>, <em class="sig-param">order='F'</em>, <em class="sig-param">imagej=False</em>, <em class="sig-param">bigtiff=True</em>, <em class="sig-param">excitation_lambda=488.0</em>, <em class="sig-param">compress=0</em>, <em class="sig-param">var_name_hdf5='mov'</em>, <em class="sig-param">sess_desc='some_description'</em>, <em class="sig-param">identifier='some identifier'</em>, <em class="sig-param">exp_desc='experiment description'</em>, <em class="sig-param">imaging_plane_description='some imaging plane description'</em>, <em class="sig-param">emission_lambda=520.0</em>, <em class="sig-param">indicator='OGB-1'</em>, <em class="sig-param">location='brain'</em>, <em class="sig-param">starting_time=0.0</em>, <em class="sig-param">experimenter='Dr Who'</em>, <em class="sig-param">lab_name=''</em>, <em class="sig-param">institution=''</em>, <em class="sig-param">experiment_description='Experiment Description'</em>, <em class="sig-param">session_id='Session ID'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.timeseries.timeseries.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the timeseries in single precision. Supported formats include
TIFF, NPZ, AVI, MAT, HDF5/H5, MMAP, and NWB</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name: str</dt><dd><p>name of file. Possible formats are tif, avi, npz, mmap and hdf5</p>
</dd>
<dt>to32: Bool</dt><dd><p>whether to transform to 32 bits</p>
</dd>
<dt>order: ‘F’ or ‘C’</dt><dd><p>C or Fortran order</p>
</dd>
<dt>var_name_hdf5: str</dt><dd><p>Name of hdf5 file subdirectory</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>Exception ‘Extension Unknown’</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.timeseries.concatenate">
<code class="sig-prename descclassname">caiman.base.timeseries.</code><code class="sig-name descname">concatenate</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.timeseries.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate movies</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mov: XMovie object</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="rois">
<h2>ROIs<a class="headerlink" href="#rois" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.base.rois.register_ROIs">
<code class="sig-prename descclassname">caiman.base.rois.</code><code class="sig-name descname">register_ROIs</code><span class="sig-paren">(</span><em class="sig-param">A1</em>, <em class="sig-param">A2</em>, <em class="sig-param">dims</em>, <em class="sig-param">template1=None</em>, <em class="sig-param">template2=None</em>, <em class="sig-param">align_flag=True</em>, <em class="sig-param">D=None</em>, <em class="sig-param">max_thr=0</em>, <em class="sig-param">use_opt_flow=True</em>, <em class="sig-param">thresh_cost=0.7</em>, <em class="sig-param">max_dist=10</em>, <em class="sig-param">enclosed_thr=None</em>, <em class="sig-param">print_assignment=False</em>, <em class="sig-param">plot_results=False</em>, <em class="sig-param">Cn=None</em>, <em class="sig-param">cmap='viridis'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.rois.register_ROIs" title="Permalink to this definition">¶</a></dt>
<dd><p>Register ROIs across different sessions using an intersection over union 
metric and the Hungarian algorithm for optimal matching</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>A1: ndarray or csc_matrix  # pixels x # of components</dt><dd><p>ROIs from session 1</p>
</dd>
<dt>A2: ndarray or csc_matrix  # pixels x # of components</dt><dd><p>ROIs from session 2</p>
</dd>
<dt>dims: list or tuple</dt><dd><p>dimensionality of the FOV</p>
</dd>
<dt>template1: ndarray dims</dt><dd><p>template from session 1</p>
</dd>
<dt>template2: ndarray dims</dt><dd><p>template from session 2</p>
</dd>
<dt>align_flag: bool</dt><dd><p>align the templates before matching</p>
</dd>
<dt>D: ndarray</dt><dd><p>matrix of distances in the event they are pre-computed</p>
</dd>
<dt>max_thr: scalar</dt><dd><p>max threshold parameter before binarization</p>
</dd>
<dt>use_opt_flow: bool</dt><dd><p>use dense optical flow to align templates</p>
</dd>
<dt>thresh_cost: scalar</dt><dd><p>maximum distance considered</p>
</dd>
<dt>max_dist: scalar</dt><dd><p>max distance between centroids</p>
</dd>
<dt>enclosed_thr: float</dt><dd><p>if not None set distance to at most the specified value when ground 
truth is a subset of inferred</p>
</dd>
<dt>print_assignment: bool</dt><dd><p>print pairs of matched ROIs</p>
</dd>
<dt>plot_results: bool</dt><dd><p>create a plot of matches and mismatches</p>
</dd>
<dt>Cn: ndarray</dt><dd><p>background image for plotting purposes</p>
</dd>
<dt>cmap: string</dt><dd><p>colormap for background image</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>matched_ROIs1: list</dt><dd><p>indices of matched ROIs from session 1</p>
</dd>
<dt>matched_ROIs2: list</dt><dd><p>indices of matched ROIs from session 2</p>
</dd>
<dt>non_matched1: list</dt><dd><p>indices of non-matched ROIs from session 1</p>
</dd>
<dt>non_matched2: list</dt><dd><p>indices of non-matched ROIs from session 2</p>
</dd>
<dt>performance:  list</dt><dd><p>(precision, recall, accuracy, f_1 score) with A1 taken as ground truth</p>
</dd>
<dt>A2: csc_matrix  # pixels x # of components</dt><dd><p>ROIs from session 2 aligned to session 1</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.rois.register_multisession">
<code class="sig-prename descclassname">caiman.base.rois.</code><code class="sig-name descname">register_multisession</code><span class="sig-paren">(</span><em class="sig-param">A, dims, templates=[None], align_flag=True, max_thr=0, use_opt_flow=True, thresh_cost=0.7, max_dist=10, enclosed_thr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.rois.register_multisession" title="Permalink to this definition">¶</a></dt>
<dd><p>Register ROIs across multiple sessions using an intersection over union metric
and the Hungarian algorithm for optimal matching. Registration occurs by 
aligning session 1 to session 2, keeping the union of the matched and 
non-matched components to register with session 3 and so on.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>A: list of ndarray or csc_matrix matrices # pixels x # of components</dt><dd><p>ROIs from each session</p>
</dd>
<dt>dims: list or tuple</dt><dd><p>dimensionality of the FOV</p>
</dd>
<dt>template: list of ndarray matrices of size dims</dt><dd><p>templates from each session</p>
</dd>
<dt>align_flag: bool</dt><dd><p>align the templates before matching</p>
</dd>
<dt>max_thr: scalar</dt><dd><p>max threshold parameter before binarization</p>
</dd>
<dt>use_opt_flow: bool</dt><dd><p>use dense optical flow to align templates</p>
</dd>
<dt>thresh_cost: scalar</dt><dd><p>maximum distance considered</p>
</dd>
<dt>max_dist: scalar</dt><dd><p>max distance between centroids</p>
</dd>
<dt>enclosed_thr: float</dt><dd><p>if not None set distance to at most the specified value when ground 
truth is a subset of inferred</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>A_union: csc_matrix # pixels x # of total distinct components</dt><dd><p>union of all kept ROIs</p>
</dd>
<dt>assignments: ndarray int of size # of total distinct components x # sessions</dt><dd><p>element [i,j] = k if component k from session j is mapped to component
i in the A_union matrix. If there is no much the value is NaN</p>
</dd>
<dt>matchings: list of lists</dt><dd><p>matchings[i][j] = k means that component j from session i is represented
by component k in A_union</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.rois.com">
<code class="sig-prename descclassname">caiman.base.rois.</code><code class="sig-name descname">com</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">d1</em>, <em class="sig-param">d2</em>, <em class="sig-param">d3=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.rois.com" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of the center of mass for spatial components</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>A:   np.ndarray</dt><dd><p>matrix of spatial components (d x K)</p>
</dd>
<dt>d1:  int</dt><dd><p>number of pixels in x-direction</p>
</dd>
<dt>d2:  int</dt><dd><p>number of pixels in y-direction</p>
</dd>
<dt>d3:  int</dt><dd><p>number of pixels in z-direction</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>cm:  np.ndarray</dt><dd><p>center of mass for spatial components (K x 2 or 3)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">extract_binary_masks_from_structural_channel(Y, min_area_size=30, min_hole_size=15, gSig=5, expand_method='closing', selem=array([[1., 1., 1.],</code></dt>
<dt>
<code class="sig-name descname">[1., 1., 1.],</code></dt>
<dt>
<code class="sig-name descname">[1., 1., 1.]]))</code></dt>
<dd><p>Extract binary masks by using adaptive thresholding on a structural channel</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y:                  caiman movie object</dt><dd><p>movie of the structural channel (assumed motion corrected)</p>
</dd>
<dt>min_area_size:      int</dt><dd><p>ignore components with smaller size</p>
</dd>
<dt>min_hole_size:      int</dt><dd><p>fill in holes up to that size (donuts)</p>
</dd>
<dt>gSig:               int</dt><dd><p>average radius of cell</p>
</dd>
<dt>expand_method:      string</dt><dd><p>method to expand binary masks (morphological closing or dilation)</p>
</dd>
<dt>selem:              np.array</dt><dd><p>morphological element with which to expand binary masks</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>A:                  sparse column format matrix</dt><dd><p>matrix of binary masks to be used for CNMF seeding</p>
</dd>
<dt>mR:                 np.array</dt><dd><p>mean image used to detect cell boundaries</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="memory-mapping">
<h2>Memory mapping<a class="headerlink" href="#memory-mapping" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.mmapping.load_memmap">
<code class="sig-prename descclassname">caiman.mmapping.</code><code class="sig-name descname">load_memmap</code><span class="sig-paren">(</span><em class="sig-param">filename:str</em>, <em class="sig-param">mode:str='r'</em><span class="sig-paren">)</span> &#x2192; Tuple[Any, Tuple, int]<a class="headerlink" href="#caiman.mmapping.load_memmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a memory mapped file created by the function save_memmap</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>path of the file to be loaded</p>
</dd>
<dt>mode: str</dt><dd><p>One of ‘r’, ‘r+’, ‘w+’. How to interact with files</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Yr:</dt><dd><p>memory mapped variable</p>
</dd>
<dt>dims: tuple</dt><dd><p>frame dimensions</p>
</dd>
<dt>T: int</dt><dd><p>number of frames</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>Exception “Unknown file extension”</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.mmapping.save_memmap_join">
<code class="sig-prename descclassname">caiman.mmapping.</code><code class="sig-name descname">save_memmap_join</code><span class="sig-paren">(</span><em class="sig-param">mmap_fnames:List[str], base_name:str=None, n_chunks:int=20, dview=None, add_to_mov=0</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#caiman.mmapping.save_memmap_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a large file memmap from a number of smaller files</p>
<dl>
<dt>Args:</dt><dd><p>mmap_fnames: list of memory mapped files</p>
<p>base_name: string, will be the first portion of name to be solved</p>
<p>n_chunks: number of chunks in which to subdivide when saving, smaller requires more memory</p>
<p>dview: cluster handle</p>
<p>add_to_mov: (undocumented)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.mmapping.save_memmap">
<code class="sig-prename descclassname">caiman.mmapping.</code><code class="sig-name descname">save_memmap</code><span class="sig-paren">(</span><em class="sig-param">filenames:List[str], base_name:str='Yr', resize_fact:Tuple=(1, 1, 1), remove_init:int=0, idx_xy:Tuple=None, order:str='F', xy_shifts:Union[List, NoneType]=None, is_3D:bool=False, add_to_movie:float=0, border_to_0=0, dview=None, n_chunks:int=100, slices=None</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#caiman.mmapping.save_memmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently write data from a list of tif files into a memory mappable file</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>filenames: list</dt><dd><p>list of tif files or list of numpy arrays</p>
</dd>
<dt>base_name: str</dt><dd><p>the base used to build the file name. IT MUST NOT CONTAIN “_”</p>
</dd>
<dt>resize_fact: tuple</dt><dd><p>x,y, and z downsampling factors (0.5 means downsampled by a factor 2)</p>
</dd>
<dt>remove_init: int</dt><dd><p>number of frames to remove at the begining of each tif file
(used for resonant scanning images if laser in rutned on trial by trial)</p>
</dd>
<dt>idx_xy: tuple size 2 [or 3 for 3D data]</dt><dd><p>for selecting slices of the original FOV, for instance
idx_xy = (slice(150,350,None), slice(150,350,None))</p>
</dd>
<dt>order: string</dt><dd><p>whether to save the file in ‘C’ or ‘F’ order</p>
</dd>
<dt>xy_shifts: list</dt><dd><p>x and y shifts computed by a motion correction algorithm to be applied before memory mapping</p>
</dd>
<dt>is_3D: boolean</dt><dd><p>whether it is 3D data</p>
</dd>
<dt>add_to_movie: floating-point</dt><dd><p>value to add to each image point, typically to keep negative values out.</p>
</dd>
</dl>
<p>border_to_0: (undocumented)</p>
<p>dview:       (undocumented)</p>
<p>n_chunks:    (undocumented)</p>
<dl class="simple">
<dt>slices: slice object or list of slice objects</dt><dd><p>slice can be used to select portion of the movies in time and x,y
directions. For instance 
slices = [slice(0,200),slice(0,100),slice(0,100)] will take 
the first 200 frames and the 100 pixels along x and y dimensions.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>fname_new: the name of the mapped file, the format is such that</dt><dd><p>the name will contain the frame dimensions and the number of frames</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="image-statistics">
<h2>Image statistics<a class="headerlink" href="#image-statistics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.summary_images.local_correlations">
<code class="sig-prename descclassname">caiman.summary_images.</code><code class="sig-name descname">local_correlations</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">eight_neighbours=True</em>, <em class="sig-param">swap_dim=True</em>, <em class="sig-param">order_mean=1</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.summary_images.local_correlations" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the correlation image for the input dataset Y</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y:  np.ndarray (3D or 4D)</dt><dd><p>Input movie data in 3D or 4D format</p>
</dd>
<dt>eight_neighbours: Boolean</dt><dd><p>Use 8 neighbors if true, and 4 if false for 3D data (default = True)
Use 6 neighbors for 4D data, irrespectively</p>
</dd>
<dt>swap_dim: Boolean</dt><dd><p>True indicates that time is listed in the last axis of Y (matlab format)
and moves it in the front</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>rho: d1 x d2 [x d3] matrix, cross-correlation with adjacent pixels</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.summary_images.max_correlation_image">
<code class="sig-prename descclassname">caiman.summary_images.</code><code class="sig-name descname">max_correlation_image</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">bin_size=1000</em>, <em class="sig-param">eight_neighbours=True</em>, <em class="sig-param">swap_dim=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.summary_images.max_correlation_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the max-correlation image for the input dataset Y with bin_size</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y:  np.ndarray (3D or 4D)</dt><dd><p>Input movie data in 3D or 4D format</p>
</dd>
<dt>bin_size: scalar (integer)</dt><dd><p>Length of bin_size (if last bin is smaller than bin_size &lt; 2 bin_size is increased to impose uniform bins)</p>
</dd>
<dt>eight_neighbours: Boolean</dt><dd><p>Use 8 neighbors if true, and 4 if false for 3D data (default = True)
Use 6 neighbors for 4D data, irrespectively</p>
</dd>
<dt>swap_dim: Boolean</dt><dd><p>True indicates that time is listed in the last axis of Y (matlab format)
and moves it in the front</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Cn: d1 x d2 [x d3] matrix,</dt><dd><p>max correlation image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.summary_images.correlation_pnr">
<code class="sig-prename descclassname">caiman.summary_images.</code><code class="sig-name descname">correlation_pnr</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">gSig=None</em>, <em class="sig-param">center_psf=True</em>, <em class="sig-param">swap_dim=True</em>, <em class="sig-param">background_filter='disk'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.summary_images.correlation_pnr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the correlation image and the peak-to-noise ratio (PNR) image.
If gSig is provided, then spatially filtered the video.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y:  np.ndarray (3D or 4D).</dt><dd><p>Input movie data in 3D or 4D format</p>
</dd>
<dt>gSig:  scalar or vector.</dt><dd><p>gaussian width. If gSig == None, no spatial filtering</p>
</dd>
<dt>center_psf: Boolearn</dt><dd><p>True indicates subtracting the mean of the filtering kernel</p>
</dd>
<dt>swap_dim: Boolean</dt><dd><p>True indicates that time is listed in the last axis of Y (matlab format)
and moves it in the front</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>cn: np.ndarray (2D or 3D).</dt><dd><p>local correlation image of the spatially filtered (or not)
data</p>
</dd>
<dt>pnr: np.ndarray (2D or 3D).</dt><dd><p>peak-to-noise ratios of all pixels/voxels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="motion-correction">
<h2>Motion Correction<a class="headerlink" href="#motion-correction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.motion_correction.MotionCorrect">
<em class="property">class </em><code class="sig-prename descclassname">caiman.motion_correction.</code><code class="sig-name descname">MotionCorrect</code><span class="sig-paren">(</span><em class="sig-param">fname, min_mov=None, dview=None, max_shifts=(6, 6), niter_rig=1, splits_rig=14, num_splits_to_process_rig=None, strides=(96, 96), overlaps=(32, 32), splits_els=14, num_splits_to_process_els=[7, None], upsample_factor_grid=4, max_deviation_rigid=3, shifts_opencv=True, nonneg_movie=True, gSig_filt=None, use_cuda=False, border_nan=True, pw_rigid=False, num_frames_split=80, var_name_hdf5='mov'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>class implementing motion correction operations</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.apply_shifts_movie" title="caiman.motion_correction.MotionCorrect.apply_shifts_movie"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_shifts_movie</span></code></a>(self, fname[, …])</p></td>
<td><p>Applies shifts found by registering one file to a different file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct" title="caiman.motion_correction.MotionCorrect.motion_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct</span></code></a>(self[, template, save_movie])</p></td>
<td><p>general function for performing all types of motion correction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct_pwrigid" title="caiman.motion_correction.MotionCorrect.motion_correct_pwrigid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct_pwrigid</span></code></a>(self[, save_movie, …])</p></td>
<td><p>Perform pw-rigid motion correction</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct_rigid" title="caiman.motion_correction.MotionCorrect.motion_correct_rigid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct_rigid</span></code></a>(self[, template, …])</p></td>
<td><p>Perform rigid motion correction</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.motion_correct">
<code class="sig-prename descclassname">MotionCorrect.</code><code class="sig-name descname">motion_correct</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">template=None</em>, <em class="sig-param">save_movie=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.motion_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>general function for performing all types of motion correction. The
function will perform either rigid or piecewise rigid motion correction
depending on the attribute self.pw_rigid and will perform high pass
spatial filtering for determining the motion (used in 1p data) if the
attribute self.gSig_filt is not None. A template can be passed, and the
output can be saved as a memory mapped file.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>template: nd.array, default: None</dt><dd><p>template provided by user for motion correction</p>
</dd>
<dt>save_movie: bool, default: False</dt><dd><p>flag for saving motion corrected file(s) as memory mapped file(s)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.motion_correct_rigid">
<code class="sig-prename descclassname">MotionCorrect.</code><code class="sig-name descname">motion_correct_rigid</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">template=None</em>, <em class="sig-param">save_movie=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.motion_correct_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform rigid motion correction</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>template: ndarray 2D</dt><dd><p>if known, one can pass a template to register the frames to</p>
</dd>
<dt>save_movie_rigid:Bool</dt><dd><p>save the movies vs just get the template</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self</p>
</dd>
<dt>Important Fields:</dt><dd><p>self.fname_tot_rig: name of the mmap file saved</p>
<p>self.total_template_rig: template updated by iterating  over the chunks</p>
<p>self.templates_rig: list of templates. one for each chunk</p>
<p>self.shifts_rig: shifts in x and y per frame</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.motion_correct_pwrigid">
<code class="sig-prename descclassname">MotionCorrect.</code><code class="sig-name descname">motion_correct_pwrigid</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">save_movie=True</em>, <em class="sig-param">template=None</em>, <em class="sig-param">show_template=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.motion_correct_pwrigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform pw-rigid motion correction</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>template: ndarray 2D</dt><dd><p>if known, one can pass a template to register the frames to</p>
</dd>
<dt>save_movie:Bool</dt><dd><p>save the movies vs just get the template</p>
</dd>
<dt>show_template: boolean</dt><dd><p>whether to show the updated template at each iteration</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self</p>
</dd>
<dt>Important Fields:</dt><dd><p>self.fname_tot_els: name of the mmap file saved
self.templates_els: template updated by iterating  over the chunks
self.x_shifts_els: shifts in x per frame per patch
self.y_shifts_els: shifts in y per frame per patch
self.coord_shifts_els: coordinates associated to the patch for
values in x_shifts_els and y_shifts_els
self.total_template_els: list of templates. one for each chunk</p>
</dd>
<dt>Raises:</dt><dd><p>Exception: ‘Error: Template contains NaNs, Please review the parameters’</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.apply_shifts_movie">
<code class="sig-prename descclassname">MotionCorrect.</code><code class="sig-name descname">apply_shifts_movie</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fname</em>, <em class="sig-param">rigid_shifts=True</em>, <em class="sig-param">border_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.apply_shifts_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies shifts found by registering one file to a different file. Useful
for cases when shifts computed from a structural channel are applied to a
functional channel. Currently only application of shifts through openCV is
supported.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fname: str</dt><dd><p>name of the movie to motion correct. It should not contain nans. All the loadable formats from CaImAn are acceptable</p>
</dd>
<dt>rigid_shifts: bool</dt><dd><p>apply rigid or pw-rigid shifts (must exist in the mc object)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>m_reg: caiman movie object</dt><dd><p>caiman movie object with applied shifts (not memory mapped)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.motion_correction.motion_correct_oneP_rigid">
<code class="sig-prename descclassname">caiman.motion_correction.</code><code class="sig-name descname">motion_correct_oneP_rigid</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">gSig_filt</em>, <em class="sig-param">max_shifts</em>, <em class="sig-param">dview=None</em>, <em class="sig-param">splits_rig=10</em>, <em class="sig-param">save_movie=True</em>, <em class="sig-param">border_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.motion_correct_oneP_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform rigid motion correction on one photon imaging movies</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>name of the file to correct</p>
</dd>
<dt>gSig_filt:</dt><dd><p>size of the filter. If algorithm does not work change this parameters</p>
</dd>
<dt>max_shifts: tuple of ints</dt><dd><p>max shifts in x and y allowed</p>
</dd>
<dt>dview:</dt><dd><p>handle to cluster</p>
</dd>
<dt>splits_rig: int</dt><dd><p>number of chunks for parallelizing motion correction (remember that it should hold that length_movie/num_splits_to_process_rig&gt;100)</p>
</dd>
<dt>save_movie: bool</dt><dd><p>whether to save the movie in memory mapped format</p>
</dd>
<dt>border_nan<span class="classifier">bool or string, optional</span></dt><dd><p>Specifies how to deal with borders. (True, False, ‘copy’, ‘min’)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Motion correction object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.motion_correction.motion_correct_oneP_nonrigid">
<code class="sig-prename descclassname">caiman.motion_correction.</code><code class="sig-name descname">motion_correct_oneP_nonrigid</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">gSig_filt</em>, <em class="sig-param">max_shifts</em>, <em class="sig-param">strides</em>, <em class="sig-param">overlaps</em>, <em class="sig-param">splits_els</em>, <em class="sig-param">upsample_factor_grid</em>, <em class="sig-param">max_deviation_rigid</em>, <em class="sig-param">dview=None</em>, <em class="sig-param">splits_rig=10</em>, <em class="sig-param">save_movie=True</em>, <em class="sig-param">new_templ=None</em>, <em class="sig-param">border_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.motion_correct_oneP_nonrigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform rigid motion correction on one photon imaging movies</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>name of the file to correct</p>
</dd>
<dt>gSig_filt:</dt><dd><p>size of the filter. If algorithm does not work change this parameters</p>
</dd>
<dt>max_shifts: tuple of ints</dt><dd><p>max shifts in x and y allowed</p>
</dd>
<dt>dview:</dt><dd><p>handle to cluster</p>
</dd>
<dt>splits_rig: int</dt><dd><p>number of chunks for parallelizing motion correction (remember that it should hold that length_movie/num_splits_to_process_rig&gt;100)</p>
</dd>
<dt>save_movie: bool</dt><dd><p>whether to save the movie in memory mapped format</p>
</dd>
<dt>border_nan<span class="classifier">bool or string, optional</span></dt><dd><p>specifies how to deal with borders. (True, False, ‘copy’, ‘min’)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Motion correction object</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="estimates">
<h2>Estimates<a class="headerlink" href="#estimates" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates">
<em class="property">class </em><code class="sig-prename descclassname">caiman.source_extraction.cnmf.estimates.</code><code class="sig-name descname">Estimates</code><span class="sig-paren">(</span><em class="sig-param">A=None</em>, <em class="sig-param">b=None</em>, <em class="sig-param">C=None</em>, <em class="sig-param">f=None</em>, <em class="sig-param">R=None</em>, <em class="sig-param">dims=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals" title="caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residuals</span></code></a>(self, Yr)</p></td>
<td><p>compute residual for each component (variable R)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f" title="caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_df_f</span></code></a>(self[, quantileMin, …])</p></td>
<td><p>Computes DF/F normalized fluorescence for the extracted traces.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components" title="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_components</span></code></a>(self, imgs, params[, dview])</p></td>
<td><p>Computes the quality metrics for each component and stores the indices of the components that pass user specified thresholds.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN" title="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_components_CNN</span></code></a>(self, params[, …])</p></td>
<td><p>Estimates the quality of inferred spatial components using a pretrained CNN classifier.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.filter_components" title="caiman.source_extraction.cnmf.estimates.Estimates.filter_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_components</span></code></a>(self, imgs, params[, …])</p></td>
<td><p>Filters components based on given thresholds without re-computing the quality metrics.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">manual_merge</span></code>(self, components, params)</p></td>
<td><p>merge a given list of components.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components" title="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_view_components</span></code></a>(self[, Yr, img, idx, …])</p></td>
<td><p>view spatial and temporal components interactively in a notebook</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d" title="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_view_components_3d</span></code></a>(self[, Yr, …])</p></td>
<td><p>view spatial and temporal components interactively in a notebook (version for 3d data)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.normalize_components" title="caiman.source_extraction.cnmf.estimates.Estimates.normalize_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_components</span></code></a>(self)</p></td>
<td><p>Normalizes components such that spatial components have l_2 norm 1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.play_movie" title="caiman.source_extraction.cnmf.estimates.Estimates.play_movie"><code class="xref py py-obj docutils literal notranslate"><span class="pre">play_movie</span></code></a>(self, imgs[, q_max, q_min, …])</p></td>
<td><p>Displays a movie with three panels (original data (left panel), reconstructed data (middle panel), residual (right panel))</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours" title="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_contours</span></code></a>(self[, img, idx, crd, …])</p></td>
<td><p>view contours of all spatial footprints.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb" title="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_contours_nb</span></code></a>(self[, img, idx, crd, …])</p></td>
<td><p>view contours of all spatial footprints (notebook environment).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates" title="caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicates</span></code></a>(self[, predictions, …])</p></td>
<td><p>remove neurons that heavily overlapand might be duplicates</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_small_large_neurons</span></code>(self, …[, …])</p></td>
<td><p>remove neurons that are too large or too small</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">restore_discarded_components</span></code>(self)</p></td>
<td><p>Recover components that are filtered out with the select_components method &#64;param: None &#64;return: None</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_NWB</span></code>(self, filename[, …])</p></td>
<td><p>save object in hdf5 file format</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.select_components" title="caiman.source_extraction.cnmf.estimates.Estimates.select_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_components</span></code></a>(self[, idx_components, …])</p></td>
<td><p>Keeps only a selected subset of components and removes the rest.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_spatial_components</span></code>(self[, maxthr, …])</p></td>
<td><p>threshold spatial components.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.view_components" title="caiman.source_extraction.cnmf.estimates.Estimates.view_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_components</span></code></a>(self[, Yr, img, idx])</p></td>
<td><p>view spatial and temporal components interactively</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>masks_2_neurofinder</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">compute_residuals</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>compute residual for each component (variable R)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr<span class="classifier">np.ndarray</span></dt><dd><p>movie in format pixels (d) x frames (T)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">detrend_df_f</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">quantileMin=8</em>, <em class="sig-param">frames_window=500</em>, <em class="sig-param">flag_auto=True</em>, <em class="sig-param">use_fast=False</em>, <em class="sig-param">use_residuals=True</em>, <em class="sig-param">detrend_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes DF/F normalized fluorescence for the extracted traces. See
caiman.source.extraction.utilities.detrend_df_f for details</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>quantile_min: float</dt><dd><p>quantile used to estimate the baseline (values in [0,100])</p>
</dd>
<dt>frames_window: int</dt><dd><p>number of frames for computing running quantile</p>
</dd>
<dt>flag_auto: bool</dt><dd><p>flag for determining quantile automatically (different for each
trace)</p>
</dd>
<dt>use_fast: bool</dt><dd><p>flag for using approximate fast percentile filtering</p>
</dd>
<dt>use_residuals: bool</dt><dd><p>flag for using non-deconvolved traces in DF/F calculation</p>
</dd>
<dt>detrend_only: bool (False)</dt><dd><p>flag for only subtracting baseline and not normalizing by it.
Used in 1p data processing where baseline fluorescence cannot
be determined.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>self: CNMF object</dt><dd><p>self.F_dff contains the DF/F normalized traces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">evaluate_components</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">imgs</em>, <em class="sig-param">params</em>, <em class="sig-param">dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the quality metrics for each component and stores the
indices of the components that pass user specified thresholds. The
various thresholds and parameters can be passed as inputs. If left
empty then they are read from self.params.quality’]</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>imgs: np.array (possibly memory mapped, t,x,y[,z])</dt><dd><p>Imaging data</p>
</dd>
<dt>params: params object</dt><dd><p>Parameters of the algorithm. The parameters in play here are
contained in the subdictionary params.quality:</p>
<dl class="simple">
<dt>min_SNR: float</dt><dd><p>trace SNR threshold</p>
</dd>
<dt>rval_thr: float</dt><dd><p>space correlation threshold</p>
</dd>
<dt>use_cnn: bool</dt><dd><p>flag for using the CNN classifier</p>
</dd>
<dt>min_cnn_thr: float</dt><dd><p>CNN classifier threshold</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>self: esimates object</dt><dd><dl class="simple">
<dt>self.idx_components: np.array</dt><dd><p>indices of accepted components</p>
</dd>
<dt>self.idx_components_bad: np.array</dt><dd><p>indices of rejected components</p>
</dd>
<dt>self.SNR_comp: np.array</dt><dd><p>SNR values for each temporal trace</p>
</dd>
<dt>self.r_values: np.array</dt><dd><p>space correlation values for each component</p>
</dd>
<dt>self.cnn_preds: np.array</dt><dd><p>CNN classifier values for each component</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">evaluate_components_CNN</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">params</em>, <em class="sig-param">neuron_class=1</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the quality of inferred spatial components using a
pretrained CNN classifier.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>params: params object</dt><dd><p>see .params for details</p>
</dd>
<dt>neuron_class: int</dt><dd><p>class label for neuron shapes</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>self: Estimates object</dt><dd><p>self.idx_components contains the indeced of components above
the required treshold.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.filter_components">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">filter_components</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">imgs</em>, <em class="sig-param">params</em>, <em class="sig-param">new_dict={}</em>, <em class="sig-param">dview=None</em>, <em class="sig-param">select_mode='All'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.filter_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters components based on given thresholds without re-computing
the quality metrics. If the quality metrics are not present then it
calls self.evaluate components.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>imgs: np.array (possibly memory mapped, t,x,y[,z])</dt><dd><p>Imaging data</p>
</dd>
<dt>params: params object</dt><dd><p>Parameters of the algorithm</p>
</dd>
<dt>select_mode: str</dt><dd><p>Can be ‘All’ (no subselection is made, but quality filtering is performed),
‘Accepted’ (subselection of accepted components, a field named self.accepted_list must exist),
‘Rejected’ (subselection of rejected components, a field named self.rejected_list must exist),
‘Unassigned’ (both fields above need to exist)</p>
</dd>
<dt>new_dict: dict</dt><dd><p>New dictionary with parameters to be called. The dictionary
modifies the params.quality subdictionary in the following
entries:</p>
<blockquote>
<div><dl class="simple">
<dt>min_SNR: float</dt><dd><p>trace SNR threshold</p>
</dd>
<dt>SNR_lowest: float</dt><dd><p>minimum required trace SNR</p>
</dd>
<dt>rval_thr: float</dt><dd><p>space correlation threshold</p>
</dd>
<dt>rval_lowest: float</dt><dd><p>minimum required space correlation</p>
</dd>
<dt>use_cnn: bool</dt><dd><p>flag for using the CNN classifier</p>
</dd>
<dt>min_cnn_thr: float</dt><dd><p>CNN classifier threshold</p>
</dd>
<dt>cnn_lowest: float</dt><dd><p>minimum required CNN threshold</p>
</dd>
<dt>gSig_range: list</dt><dd><p>gSig scale values for CNN classifier</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>self: estimates object</dt><dd><dl class="simple">
<dt>self.idx_components: np.array</dt><dd><p>indices of accepted components</p>
</dd>
<dt>self.idx_components_bad: np.array</dt><dd><p>indices of rejected components</p>
</dd>
<dt>self.SNR_comp: np.array</dt><dd><p>SNR values for each temporal trace</p>
</dd>
<dt>self.r_values: np.array</dt><dd><p>space correlation values for each component</p>
</dd>
<dt>self.cnn_preds: np.array</dt><dd><p>CNN classifier values for each component</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">nb_view_components</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr=None</em>, <em class="sig-param">img=None</em>, <em class="sig-param">idx=None</em>, <em class="sig-param">denoised_color=None</em>, <em class="sig-param">cmap='jet'</em>, <em class="sig-param">thr=0.99</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components" title="Permalink to this definition">¶</a></dt>
<dd><p>view spatial and temporal components interactively in a notebook</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr<span class="classifier">np.ndarray</span></dt><dd><p>movie in format pixels (d) x frames (T)</p>
</dd>
<dt>img<span class="classifier">np.ndarray</span></dt><dd><p>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</p>
</dd>
<dt>idx<span class="classifier">list</span></dt><dd><p>list of components to be plotted</p>
</dd>
<dt>thr: double</dt><dd><p>threshold regulating the extent of the displayed patches</p>
</dd>
<dt>denoised_color: string or None</dt><dd><p>color name (e.g. ‘red’) or hex color code (e.g. ‘#F0027F’)</p>
</dd>
<dt>cmap: string</dt><dd><p>name of colormap (e.g. ‘viridis’) used to plot image_neurons</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">nb_view_components_3d</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr=None</em>, <em class="sig-param">image_type='mean'</em>, <em class="sig-param">dims=None</em>, <em class="sig-param">max_projection=False</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">denoised_color=None</em>, <em class="sig-param">cmap='jet'</em>, <em class="sig-param">thr=0.9</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>view spatial and temporal components interactively in a notebook
(version for 3d data)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr<span class="classifier">np.ndarray</span></dt><dd><p>movie in format pixels (d) x frames (T) (only required to
compute the correlation image)</p>
</dd>
<dt>dims: tuple of ints</dt><dd><p>dimensions of movie (x, y and z)</p>
</dd>
<dt>image_type: ‘mean’|’max’|’corr’</dt><dd><p>image to be overlaid to neurons (average of shapes,
maximum of shapes or nearest neigbor correlation of raw data)</p>
</dd>
<dt>max_projection: bool</dt><dd><p>plot max projection along specified axis if True, o/w plot layers</p>
</dd>
<dt>axis: int (0, 1 or 2)</dt><dd><p>axis along which max projection is performed or layers are shown</p>
</dd>
<dt>thr: scalar between 0 and 1</dt><dd><p>Energy threshold for computing contours</p>
</dd>
<dt>denoised_color: string or None</dt><dd><p>color name (e.g. ‘red’) or hex color code (e.g. ‘#F0027F’)</p>
</dd>
<dt>cmap: string</dt><dd><p>name of colormap (e.g. ‘viridis’) used to plot image_neurons</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.normalize_components">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">normalize_components</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.normalize_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes components such that spatial components have l_2 norm 1</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.play_movie">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">play_movie</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">imgs</em>, <em class="sig-param">q_max=99.75</em>, <em class="sig-param">q_min=2</em>, <em class="sig-param">gain_res=1</em>, <em class="sig-param">magnification=1</em>, <em class="sig-param">include_bck=True</em>, <em class="sig-param">frame_range=slice(None</em>, <em class="sig-param">None</em>, <em class="sig-param">None)</em>, <em class="sig-param">bpx=0</em>, <em class="sig-param">thr=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.play_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays a movie with three panels (original data (left panel),
reconstructed data (middle panel), residual (right panel))</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>imgs: np.array (possibly memory mapped, t,x,y[,z])</dt><dd><p>Imaging data</p>
</dd>
<dt>q_max: float (values in [0, 100])</dt><dd><p>percentile for maximum plotting value</p>
</dd>
<dt>q_min: float (values in [0, 100])</dt><dd><p>percentile for minimum plotting value</p>
</dd>
<dt>gain_res: float</dt><dd><p>amplification factor for residual movie</p>
</dd>
<dt>magnification: float</dt><dd><p>magnification factor for whole movie</p>
</dd>
<dt>include_bck: bool</dt><dd><p>flag for including background in original and reconstructed movie</p>
</dd>
<dt>frame_rage: range or slice or list</dt><dd><p>display only a subset of frames</p>
</dd>
<dt>bpx: int</dt><dd><p>number of pixels to exclude on each border</p>
</dd>
<dt>thr: float (values in [0, 1[)</dt><dd><p>threshold value for contours, no contours if thr=0</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self (to stop the movie press ‘q’)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">plot_contours</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">img=None</em>, <em class="sig-param">idx=None</em>, <em class="sig-param">crd=None</em>, <em class="sig-param">thr_method='max'</em>, <em class="sig-param">thr='0.2'</em>, <em class="sig-param">display_numbers=True</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>view contours of all spatial footprints.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>img<span class="classifier">np.ndarray</span></dt><dd><p>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</p>
</dd>
<dt>idx<span class="classifier">list</span></dt><dd><p>list of accepted components</p>
</dd>
<dt>crd<span class="classifier">list</span></dt><dd><p>list of coordinates (if empty they are computed)</p>
</dd>
<dt>thr_method<span class="classifier">str</span></dt><dd><p>thresholding method for computing contours (‘max’, ‘nrg’)</p>
</dd>
<dt>thr<span class="classifier">float</span></dt><dd><p>threshold value</p>
</dd>
<dt>display_numbers<span class="classifier">bool</span></dt><dd><p>flag for displaying the id number of each contour</p>
</dd>
<dt>params<span class="classifier">params object</span></dt><dd><p>set of dictionary containing the various parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">plot_contours_nb</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">img=None</em>, <em class="sig-param">idx=None</em>, <em class="sig-param">crd=None</em>, <em class="sig-param">thr_method='max'</em>, <em class="sig-param">thr='0.2'</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb" title="Permalink to this definition">¶</a></dt>
<dd><p>view contours of all spatial footprints (notebook environment).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>img<span class="classifier">np.ndarray</span></dt><dd><p>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</p>
</dd>
<dt>idx<span class="classifier">list</span></dt><dd><p>list of accepted components</p>
</dd>
<dt>crd<span class="classifier">list</span></dt><dd><p>list of coordinates (if empty they are computed)</p>
</dd>
<dt>thr_method<span class="classifier">str</span></dt><dd><p>thresholding method for computing contours (‘max’, ‘nrg’)</p>
</dd>
<dt>thr<span class="classifier">float</span></dt><dd><p>threshold value</p>
</dd>
<dt>params<span class="classifier">params object</span></dt><dd><p>set of dictionary containing the various parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">remove_duplicates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">predictions=None</em>, <em class="sig-param">r_values=None</em>, <em class="sig-param">dist_thr=0.1</em>, <em class="sig-param">min_dist=10</em>, <em class="sig-param">thresh_subset=0.6</em>, <em class="sig-param">plot_duplicates=False</em>, <em class="sig-param">select_comp=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>remove neurons that heavily overlapand might be duplicates</p>
<dl class="simple">
<dt>Args:</dt><dd><p>predictions
r_values
dist_thr
min_dist
thresh_subset
plot_duplicates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.select_components">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">select_components</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">idx_components=None</em>, <em class="sig-param">use_object=False</em>, <em class="sig-param">save_discarded_components=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.select_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Keeps only a selected subset of components and removes the rest.
The subset can be either user defined with the variable idx_components
or read from the estimates object. The flag use_object determines this
choice. If no subset is present then all components are kept.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>idx_components: list</dt><dd><p>indices of components to be kept</p>
</dd>
<dt>use_object: bool</dt><dd><p>Flag to use self.idx_components for reading the indices.</p>
</dd>
<dt>save_discarded_components: bool</dt><dd><p>whether to save the components from initialization so that they can be restored using the restore_discarded_components method</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self: Estimates object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.view_components">
<code class="sig-prename descclassname">Estimates.</code><code class="sig-name descname">view_components</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr=None</em>, <em class="sig-param">img=None</em>, <em class="sig-param">idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.view_components" title="Permalink to this definition">¶</a></dt>
<dd><p>view spatial and temporal components interactively</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr<span class="classifier">np.ndarray</span></dt><dd><p>movie in format pixels (d) x frames (T)</p>
</dd>
<dt>img<span class="classifier">np.ndarray</span></dt><dd><p>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</p>
</dd>
<dt>idx<span class="classifier">list</span></dt><dd><p>list of components to be plotted</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="deconvolution">
<h2>Deconvolution<a class="headerlink" href="#deconvolution" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.deconvolution.constrained_foopsi">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.deconvolution.</code><code class="sig-name descname">constrained_foopsi</code><span class="sig-paren">(</span><em class="sig-param">fluor, bl=None, c1=None, g=None, sn=None, p=None, method_deconvolution='oasis', bas_nonneg=True, noise_range=[0.25, 0.5], noise_method='logmexp', lags=5, fudge_factor=1.0, verbosity=False, solvers=None, optimize_g=0, s_min=None, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.deconvolution.constrained_foopsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer the most likely discretized spike train underlying a fluorescence trace</p>
<p>It relies on a noise constrained deconvolution approach</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>fluor: np.ndarray</dt><dd><p>One dimensional array containing the fluorescence intensities with
one entry per time-bin.</p>
</dd>
<dt>bl: [optional] float</dt><dd><p>Fluorescence baseline value. If no value is given, then bl is estimated
from the data.</p>
</dd>
<dt>c1: [optional] float</dt><dd><p>value of calcium at time 0</p>
</dd>
<dt>g: [optional] list,float</dt><dd><p>Parameters of the AR process that models the fluorescence impulse response.
Estimated from the data if no value is given</p>
</dd>
<dt>sn: float, optional</dt><dd><p>Standard deviation of the noise distribution.  If no value is given,
then sn is estimated from the data.</p>
</dd>
<dt>p: int</dt><dd><p>order of the autoregression model</p>
</dd>
<dt>method_deconvolution: [optional] string</dt><dd><p>solution method for basis projection pursuit ‘cvx’ or ‘cvxpy’ or ‘oasis’</p>
</dd>
<dt>bas_nonneg: bool</dt><dd><p>baseline strictly non-negative</p>
</dd>
<dt>noise_range:  list of two elms</dt><dd><p>frequency range for averaging noise PSD</p>
</dd>
<dt>noise_method: string</dt><dd><p>method of averaging noise PSD</p>
</dd>
<dt>lags: int</dt><dd><p>number of lags for estimating time constants</p>
</dd>
<dt>fudge_factor: float</dt><dd><p>fudge factor for reducing time constant bias</p>
</dd>
<dt>verbosity: bool</dt><dd><p>display optimization details</p>
</dd>
<dt>solvers: list string</dt><dd><p>primary and secondary (if problem unfeasible for approx solution) solvers
to be used with cvxpy, default is [‘ECOS’,’SCS’]</p>
</dd>
<dt>optimize_g<span class="classifier">[optional] int, only applies to method ‘oasis’</span></dt><dd><p>Number of large, isolated events to consider for optimizing g.
If optimize_g=0 (default) the provided or estimated g is not further optimized.</p>
</dd>
<dt>s_min<span class="classifier">float, optional, only applies to method ‘oasis’</span></dt><dd><p>Minimal non-zero activity within each bin (minimal ‘spike size’).
For negative values the threshold is abs(s_min) * sn * sqrt(1-g)
If None (default) the standard L1 penalty is used
If 0 the threshold is determined automatically such that RSS &lt;= sn^2 T</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>c: np.ndarray float</dt><dd><p>The inferred denoised fluorescence signal at each time-bin.</p>
</dd>
</dl>
<p>bl, c1, g, sn : As explained above</p>
<dl class="simple">
<dt>sp: ndarray of float</dt><dd><p>Discretized deconvolved neural activity (spikes)</p>
</dd>
<dt>lam: float</dt><dd><p>Regularization parameter</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>Exception(“You must specify the value of p”)</p>
<p>Exception(‘OASIS is currently only implemented for p=1 and p=2’)</p>
<p>Exception(‘Undefined Deconvolution Method’)</p>
</dd>
<dt>References:</dt><dd><ul class="simple">
<li><p>Pnevmatikakis et al. 2016. Neuron, in press, <a class="reference external" href="http://dx.doi.org/10.1016/j.neuron.2015.11.037">http://dx.doi.org/10.1016/j.neuron.2015.11.037</a></p></li>
<li><p>Machado et al. 2015. Cell 162(2):338-350</p></li>
</ul>
</dd>
</dl>
<p>image: docs/img/deconvolution.png
image: docs/img/evaluationcomponent.png</p>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.deconvolution.constrained_oasisAR2">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.deconvolution.</code><code class="sig-name descname">constrained_oasisAR2</code><span class="sig-paren">(</span><em class="sig-param">y</em>, <em class="sig-param">g</em>, <em class="sig-param">sn</em>, <em class="sig-param">optimize_b=True</em>, <em class="sig-param">b_nonneg=True</em>, <em class="sig-param">optimize_g=0</em>, <em class="sig-param">decimate=5</em>, <em class="sig-param">shift=100</em>, <em class="sig-param">window=None</em>, <em class="sig-param">tol=1e-09</em>, <em class="sig-param">max_iter=1</em>, <em class="sig-param">penalty=1</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.deconvolution.constrained_oasisAR2" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer the most likely discretized spike train underlying an AR(2) fluorescence trace</p>
<p>Solves the noise constrained sparse non-negative deconvolution problem
min (s)_1 subject to (c-y)^2 = sn^2 T and s_t = c_t-g1 c_{t-1}-g2 c_{t-2} &gt;= 0</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>y<span class="classifier">array of float</span></dt><dd><p>One dimensional array containing the fluorescence intensities (with baseline
already subtracted) with one entry per time-bin.</p>
</dd>
<dt>g<span class="classifier">(float, float)</span></dt><dd><p>Parameters of the AR(2) process that models the fluorescence impulse response.</p>
</dd>
<dt>sn<span class="classifier">float</span></dt><dd><p>Standard deviation of the noise distribution.</p>
</dd>
<dt>optimize_b<span class="classifier">bool, optional, default True</span></dt><dd><p>Optimize baseline if True else it is set to 0, see y.</p>
</dd>
<dt>b_nonneg: bool, optional, default True</dt><dd><p>Enforce strictly non-negative baseline if True.</p>
</dd>
<dt>optimize_g<span class="classifier">int, optional, default 0</span></dt><dd><p>Number of large, isolated events to consider for optimizing g.
No optimization if optimize_g=0.</p>
</dd>
<dt>decimate<span class="classifier">int, optional, default 5</span></dt><dd><p>Decimation factor for estimating hyper-parameters faster on decimated data.</p>
</dd>
<dt>shift<span class="classifier">int, optional, default 100</span></dt><dd><p>Number of frames by which to shift window from on run of NNLS to the next.</p>
</dd>
<dt>window<span class="classifier">int, optional, default None (200 or larger dependend on g)</span></dt><dd><p>Window size.</p>
</dd>
<dt>tol<span class="classifier">float, optional, default 1e-9</span></dt><dd><p>Tolerance parameter.</p>
</dd>
<dt>max_iter<span class="classifier">int, optional, default 1</span></dt><dd><p>Maximal number of iterations.</p>
</dd>
<dt>penalty<span class="classifier">int, optional, default 1</span></dt><dd><p>Sparsity penalty. 1: min (s)_1  0: min (s)_0</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>c<span class="classifier">array of float</span></dt><dd><p>The inferred denoised fluorescence signal at each time-bin.</p>
</dd>
<dt>s<span class="classifier">array of float</span></dt><dd><p>Discretized deconvolved neural activity (spikes).</p>
</dd>
<dt>b<span class="classifier">float</span></dt><dd><p>Fluorescence baseline value.</p>
</dd>
<dt>(g1, g2)<span class="classifier">tuple of float</span></dt><dd><p>Parameters of the AR(2) process that models the fluorescence impulse response.</p>
</dd>
<dt>lam<span class="classifier">float</span></dt><dd><p>Sparsity penalty parameter lambda of dual problem.</p>
</dd>
</dl>
</dd>
<dt>References:</dt><dd><p>Friedrich J and Paninski L, NIPS 2016
Friedrich J, Zhou P, and Paninski L, arXiv 2016</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="parameter-setting">
<h2>Parameter Setting<a class="headerlink" href="#parameter-setting" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams">
<em class="property">class </em><code class="sig-prename descclassname">caiman.source_extraction.cnmf.params.</code><code class="sig-name descname">CNMFParams</code><span class="sig-paren">(</span><em class="sig-param">fnames=None, dims=None, dxy=(1, 1), border_pix=0, del_duplicates=False, low_rank_background=True, memory_fact=1, n_processes=1, nb_patch=1, p_ssub=2, p_tsub=2, remove_very_bad_comps=False, rf=None, stride=None, check_nan=True, n_pixels_per_process=None, k=30, alpha_snmf=1000.0, center_psf=False, gSig=[5, 5], gSiz=None, init_iter=2, method_init='greedy_roi', min_corr=0.85, min_pnr=20, gnb=1, normalize_init=True, options_local_NMF=None, ring_size_factor=1.5, rolling_length=100, rolling_sum=True, ssub=2, ssub_B=2, tsub=2, block_size_spat=5000, num_blocks_per_run_spat=20, block_size_temp=5000, num_blocks_per_run_temp=20, update_background_components=True, method_deconvolution='oasis', p=2, s_min=None, do_merge=True, merge_thresh=0.8, decay_time=0.4, fr=30, min_SNR=2.5, rval_thr=0.8, N_samples_exceptionality=None, batch_update_suff_stat=False, expected_comps=500, iters_shape=5, max_comp_update_shape=inf, max_num_added=5, min_num_trial=5, minibatch_shape=100, minibatch_suff_stat=5, n_refit=0, num_times_comp_updated=inf, simultaneously=False, sniper_mode=False, test_both=False, thresh_CNN_noisy=0.5, thresh_fitness_delta=-50, thresh_fitness_raw=None, thresh_overlap=0.5, update_freq=200, update_num_comps=True, use_dense=True, use_peak_max=True, only_init_patch=True, var_name_hdf5='mov', params_dict={}</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.params.CNMFParams.get" title="caiman.source_extraction.cnmf.params.CNMFParams.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(self, group, key)</p></td>
<td><p>Get a value for a given group and key.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.params.CNMFParams.get_group" title="caiman.source_extraction.cnmf.params.CNMFParams.get_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_group</span></code></a>(self, group)</p></td>
<td><p>Get the dictionary of key-value pairs for a group.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.params.CNMFParams.set" title="caiman.source_extraction.cnmf.params.CNMFParams.set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set</span></code></a>(self, group, val_dict[, …])</p></td>
<td><p>Add key-value pairs to a group. Existing key-value pairs will be overwritten</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>change_params</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_dict</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.set">
<code class="sig-prename descclassname">CNMFParams.</code><code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">group</em>, <em class="sig-param">val_dict</em>, <em class="sig-param">set_if_not_exists=False</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.set" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Add key-value pairs to a group. Existing key-value pairs will be overwritten</dt><dd><p>if specified in val_dict, but not deleted.</p>
</dd>
<dt>Args:</dt><dd><p>group: The name of the group.
val_dict: A dictionary with key-value pairs to be set for the group.
set_if_not_exists: Whether to set a key-value pair in a group if the key does not currently exist in the group.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.get">
<code class="sig-prename descclassname">CNMFParams.</code><code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">group</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a value for a given group and key. Raises an exception if no such group/key combination exists.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>group: The name of the group.
key: The key for the property in the group of interest.</p>
</dd>
</dl>
<p>Returns: The value for the group/key combination.</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.get_group">
<code class="sig-prename descclassname">CNMFParams.</code><code class="sig-name descname">get_group</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.get_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dictionary of key-value pairs for a group.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>group: The name of the group.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.change_params">
<code class="sig-prename descclassname">CNMFParams.</code><code class="sig-name descname">change_params</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">params_dict</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.change_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cnmf">
<h2>CNMF<a class="headerlink" href="#cnmf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF">
<em class="property">class </em><code class="sig-prename descclassname">caiman.source_extraction.cnmf.cnmf.</code><code class="sig-name descname">CNMF</code><span class="sig-paren">(</span><em class="sig-param">n_processes, k=5, gSig=[4, 4], gSiz=None, merge_thresh=0.8, p=2, dview=None, Ain=None, Cin=None, b_in=None, f_in=None, do_merge=True, ssub=2, tsub=2, p_ssub=1, p_tsub=1, method_init='greedy_roi', alpha_snmf=None, rf=None, stride=None, memory_fact=1, gnb=1, nb_patch=1, only_init_patch=False, method_deconvolution='oasis', n_pixels_per_process=4000, block_size_temp=5000, num_blocks_per_run_temp=20, block_size_spat=5000, num_blocks_per_run_spat=20, check_nan=True, skip_refinement=False, normalize_init=True, options_local_NMF=None, minibatch_shape=100, minibatch_suff_stat=3, update_num_comps=True, rval_thr=0.9, thresh_fitness_delta=-20, thresh_fitness_raw=None, thresh_overlap=0.5, max_comp_update_shape=inf, num_times_comp_updated=inf, batch_update_suff_stat=False, s_min=None, remove_very_bad_comps=False, border_pix=0, low_rank_background=True, update_background_components=True, rolling_sum=True, rolling_length=100, min_corr=0.85, min_pnr=20, ring_size_factor=1.5, center_psf=False, use_dense=True, deconv_flag=True, simultaneously=False, n_refit=0, del_duplicates=False, N_samples_exceptionality=None, max_num_added=3, min_num_trial=2, thresh_CNN_noisy=0.5, fr=30, decay_time=0.4, min_SNR=2.5, ssub_B=2, init_iter=2, sniper_mode=False, use_peak_max=False, test_both=False, expected_comps=500, params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF" title="Permalink to this definition">¶</a></dt>
<dd><p>Source extraction using constrained non-negative matrix factorization.</p>
<p>The general class which is used to produce a factorization of the Y matrix being the video
it computes it using all the files inside of cnmf folder.
Its architecture is similar to the one of scikit-learn calling the function fit to run everything which is part
of the structure of the class</p>
<p>it is calling everyfunction from the cnmf folder
you can find out more at how the functions are called and how they are laid out at the ipython notebook</p>
<p>See Also:
&#64;url <a class="reference external" href="http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3">http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3</a>
.. image:: docs/img/quickintro.png
&#64;author andrea giovannucci</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints" title="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HALS4footprints</span></code></a>(self, Yr[, update_bck, num_iter])</p></td>
<td><p>Uses hierarchical alternating least squares to update shapes and background</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces" title="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HALS4traces</span></code></a>(self, Yr[, groups, use_groups, …])</p></td>
<td><p>Solves C, f = argmin_C ||Yr-AC-bf|| using block-coordinate decent.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.compute_residuals" title="caiman.source_extraction.cnmf.cnmf.CNMF.compute_residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residuals</span></code></a>(self, Yr)</p></td>
<td><p>Compute residual trace for each component (variable YrA).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve" title="caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deconvolve</span></code></a>(self[, p, method_deconvolution, …])</p></td>
<td><p>Performs deconvolution on already extracted traces using constrained foopsi.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit" title="caiman.source_extraction.cnmf.cnmf.CNMF.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(self, images[, indices])</p></td>
<td><p>This method uses the cnmf algorithm to find sources in data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit_file" title="caiman.source_extraction.cnmf.cnmf.CNMF.fit_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_file</span></code></a>(self[, motion_correct, indices])</p></td>
<td><p>This method packages the analysis pipeline (motion correction, memory mapping, patch based CNMF processing) in a single method that can be called on a specific (sequence of) file(s).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.initialize" title="caiman.source_extraction.cnmf.cnmf.CNMF.initialize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize</span></code></a>(self, Y, \*\*kwargs)</p></td>
<td><p>Component initialization</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps" title="caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_comps</span></code></a>(self, Y[, mx, fast_merge])</p></td>
<td><p>merges components</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.preprocess" title="caiman.source_extraction.cnmf.cnmf.CNMF.preprocess"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocess</span></code></a>(self, Yr)</p></td>
<td><p>Examines data to remove corrupted pixels and computes the noise level estimate fo each pixel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.refit" title="caiman.source_extraction.cnmf.cnmf.CNMF.refit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refit</span></code></a>(self, images[, dview])</p></td>
<td><p>Refits the data using CNMF initialized from a previous interation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.remove_components" title="caiman.source_extraction.cnmf.cnmf.CNMF.remove_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_components</span></code></a>(self, ind_rm)</p></td>
<td><p>Remove a specified list of components from the CNMF object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.save" title="caiman.source_extraction.cnmf.cnmf.CNMF.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(self, filename)</p></td>
<td><p>save object in hdf5 file format</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial" title="caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_spatial</span></code></a>(self, Y[, use_init])</p></td>
<td><p>Updates spatial components</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal" title="caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_temporal</span></code></a>(self, Y[, use_init])</p></td>
<td><p>Updates temporal components</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.fit">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">self, images, indices=[slice(None, None, None), slice(None, None, None)]</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses the cnmf algorithm to find sources in data.
it is calling every function from the cnmf folder
you can find out more at how the functions are called and how they are laid out at the ipython notebook</p>
<dl>
<dt>Args:</dt><dd><p>images : mapped np.ndarray of shape (t,x,y[,z]) containing the images that vary over time.</p>
<p>indices: list of slice objects along dimensions (x,y[,z]) for processing only part of the FOV</p>
</dd>
<dt>Returns:</dt><dd><p>self: updated using the cnmf algorithm with C,A,S,b,f computed according to the given initial values</p>
</dd>
</dl>
<p>Raises:
Exception ‘You need to provide a memory mapped file as input if you use patches!!’</p>
<p>See Also:
..image::docs/img/quickintro.png</p>
<p><a class="reference external" href="http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3">http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3</a></p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.refit">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">refit</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">images</em>, <em class="sig-param">dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.refit" title="Permalink to this definition">¶</a></dt>
<dd><p>Refits the data using CNMF initialized from a previous interation</p>
<dl class="simple">
<dt>Args:</dt><dd><p>images
dview</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>cnm</dt><dd><p>A new CNMF object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.fit_file">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">fit_file</code><span class="sig-paren">(</span><em class="sig-param">self, motion_correct=False, indices=[slice(None, None, None), slice(None, None, None)]</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit_file" title="Permalink to this definition">¶</a></dt>
<dd><p>This method packages the analysis pipeline (motion correction, memory
mapping, patch based CNMF processing) in a single method that can be
called on a specific (sequence of) file(s). It is assumed that the CNMF
object already contains a params object where the location of the files
and all the relevant parameters have been specified. The method does
not perform the quality evaluation step. Consult demo_pipeline for an
example.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>motion_correct (bool)</dt><dd><p>flag for performing motion correction</p>
</dd>
<dt>indices (list of slice objects)</dt><dd><p>perform analysis only on a part of the FOV</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>cnmf object with the current estimates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.save">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object in hdf5 file format</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>path to the hdf5 file containing the saved object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">deconvolve</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">p=None</em>, <em class="sig-param">method_deconvolution=None</em>, <em class="sig-param">bas_nonneg=None</em>, <em class="sig-param">noise_method=None</em>, <em class="sig-param">optimize_g=0</em>, <em class="sig-param">s_min=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs deconvolution on already extracted traces using
constrained foopsi.</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">update_spatial</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Y</em>, <em class="sig-param">use_init=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates spatial components</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y:  np.array (d1*d2) x T</dt><dd><p>input data</p>
</dd>
<dt>use_init: bool</dt><dd><p>use Cin, f_in for computing A, b otherwise use C, f</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>self</dt><dd><p>modified values self.estimates.A, self.estimates.b possibly self.estimates.C, self.estimates.f</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">update_temporal</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Y</em>, <em class="sig-param">use_init=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates temporal components</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y:  np.array (d1*d2) x T</dt><dd><p>input data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.compute_residuals">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">compute_residuals</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.compute_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute residual trace for each component (variable YrA).
WARNING: At the moment this method is valid only for the 2p processing
pipeline</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr<span class="classifier">np.ndarray</span></dt><dd><p>movie in format pixels (d) x frames (T)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.remove_components">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">remove_components</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ind_rm</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.remove_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a specified list of components from the CNMF object.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ind_rm<span class="classifier">list</span></dt><dd><p>indices of components to be removed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">HALS4traces</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr</em>, <em class="sig-param">groups=None</em>, <em class="sig-param">use_groups=False</em>, <em class="sig-param">order=None</em>, <em class="sig-param">update_bck=True</em>, <em class="sig-param">bck_non_neg=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves C, f = argmin_C ||Yr-AC-bf|| using block-coordinate decent.
Can use groups to update non-overlapping components in parallel or a
specified order.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr<span class="classifier">np.array (possibly memory mapped, (x,y,[,z]) x t)</span></dt><dd><p>Imaging data reshaped in matrix format</p>
</dd>
<dt>groups<span class="classifier">list of sets</span></dt><dd><p>grouped components to be updated simultaneously</p>
</dd>
<dt>use_groups<span class="classifier">bool</span></dt><dd><p>flag for using groups</p>
</dd>
<dt>order<span class="classifier">list</span></dt><dd><p>Update components in that order (used if nonempty and groups=None)</p>
</dd>
<dt>update_bck<span class="classifier">bool</span></dt><dd><p>Flag for updating temporal background components</p>
</dd>
<dt>bck_non_neg<span class="classifier">bool</span></dt><dd><p>Require temporal background to be non-negative</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self (updated values for self.estimates.C, self.estimates.f, self.estimates.YrA)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">HALS4footprints</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr</em>, <em class="sig-param">update_bck=True</em>, <em class="sig-param">num_iter=2</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses hierarchical alternating least squares to update shapes and
background</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr: np.array (possibly memory mapped, (x,y,[,z]) x t)</dt><dd><p>Imaging data reshaped in matrix format</p>
</dd>
<dt>update_bck: bool</dt><dd><p>flag for updating spatial background components</p>
</dd>
<dt>num_iter: int</dt><dd><p>number of iterations</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self (updated values for self.estimates.A and self.estimates.b)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">merge_comps</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Y</em>, <em class="sig-param">mx=50</em>, <em class="sig-param">fast_merge=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps" title="Permalink to this definition">¶</a></dt>
<dd><p>merges components</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.initialize">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Y</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Component initialization</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.preprocess">
<code class="sig-prename descclassname">CNMF.</code><code class="sig-name descname">preprocess</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">Yr</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Examines data to remove corrupted pixels and computes the noise level
estimate fo each pixel.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Yr: np.array (or memmap.array)</dt><dd><p>2d array of data (pixels x timesteps) typically in memory
mapped form</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.cnmf.load_CNMF">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.cnmf.</code><code class="sig-name descname">load_CNMF</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">n_processes=1</em>, <em class="sig-param">dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.load_CNMF" title="Permalink to this definition">¶</a></dt>
<dd><p>load object saved with the CNMF save method</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>hdf5 file name containing the saved object</p>
</dd>
<dt>dview: multiprocessingor ipyparallel object</dt><dd><p>useful to set up parllelization in the objects</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="online-cnmf-onacid">
<h2>Online CNMF (OnACID)<a class="headerlink" href="#online-cnmf-onacid" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID">
<em class="property">class </em><code class="sig-prename descclassname">caiman.source_extraction.cnmf.online_cnmf.</code><code class="sig-name descname">OnACID</code><span class="sig-paren">(</span><em class="sig-param">params=None</em>, <em class="sig-param">estimates=None</em>, <em class="sig-param">path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID" title="Permalink to this definition">¶</a></dt>
<dd><p>Source extraction of streaming data using online matrix factorization.
The class can be initialized by passing a “params” object for setting up
the relevant parameters and an “Estimates” object for setting an initial
state of the algorithm (optional)</p>
<dl class="simple">
<dt>Methods:</dt><dd><dl class="simple">
<dt>initialize_online: </dt><dd><p>Initialize the online algorithm using a provided method, and prepare
the online object</p>
</dd>
<dt>_prepare_object: </dt><dd><p>Prepare the online object given a set of estimates</p>
</dd>
<dt>fit_next:</dt><dd><p>Fit the algorithm on the next data frame</p>
</dd>
<dt>fit_online:</dt><dd><p>Run the entire online pipeline on a given list of files</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_next</span></code></a>(self, t, frame_in[, num_iters_hals])</p></td>
<td><p>This method fits the next frame using the online cnmf algorithm and updates the object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_online</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Implements the caiman online algorithm on the list of files fls.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.save" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(self, filename)</p></td>
<td><p>save object in hdf5 file format</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>create_frame</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>initialize_online</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>load_CNMF_from_file</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online">
<code class="sig-prename descclassname">OnACID.</code><code class="sig-name descname">fit_online</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the caiman online algorithm on the list of files fls. The
files are taken in alpha numerical order and are assumed to each have
the same number of frames (except the last one that can be shorter).
Caiman online is initialized using the seeded or bare initialization
methods.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fls: list</dt><dd><p>list of files to be processed</p>
</dd>
<dt>init_batch: int</dt><dd><p>number of frames to be processed during initialization</p>
</dd>
<dt>epochs: int</dt><dd><p>number of passes over the data</p>
</dd>
<dt>motion_correct: bool</dt><dd><p>flag for performing motion correction</p>
</dd>
<dt>kwargs: dict</dt><dd><p>additional parameters used to modify self.params.online’]
see options.[‘online’] for details</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>self (results of caiman online)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next">
<code class="sig-prename descclassname">OnACID.</code><code class="sig-name descname">fit_next</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">t</em>, <em class="sig-param">frame_in</em>, <em class="sig-param">num_iters_hals=3</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next" title="Permalink to this definition">¶</a></dt>
<dd><p>This method fits the next frame using the online cnmf algorithm and
updates the object.</p>
<dl class="simple">
<dt>Args</dt><dd><dl class="simple">
<dt>t<span class="classifier">int</span></dt><dd><p>time measured in number of frames</p>
</dd>
<dt>frame_in<span class="classifier">array</span></dt><dd><p>flattened array of shape (x * y [ * z],) containing the t-th image.</p>
</dd>
<dt>num_iters_hals: int, optional</dt><dd><p>maximal number of iterations for HALS (NNLS via blockCD)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.save">
<code class="sig-prename descclassname">OnACID.</code><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object in hdf5 file format</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>path to the hdf5 file containing the saved object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.initialize_online">
<code class="sig-prename descclassname">OnACID.</code><code class="sig-name descname">initialize_online</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.initialize_online" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.online_cnmf.load_OnlineCNMF">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.online_cnmf.</code><code class="sig-name descname">load_OnlineCNMF</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.load_OnlineCNMF" title="Permalink to this definition">¶</a></dt>
<dd><p>load object saved with the CNMF save method</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filename: str</dt><dd><p>hdf5 file name containing the saved object</p>
</dd>
<dt>dview: multiprocessingor ipyparallel object</dt><dd><p>useful to set up parllelization in the objects</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="preprocessing">
<h2>Preprocessing<a class="headerlink" href="#preprocessing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.pre_processing.preprocess_data">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.pre_processing.</code><code class="sig-name descname">preprocess_data</code><span class="sig-paren">(</span><em class="sig-param">Y, sn=None, dview=None, n_pixels_per_process=100, noise_range=[0.25, 0.5], noise_method='logmexp', compute_g=False, p=2, lags=5, include_noise=False, pixels=None, max_num_samples_fft=3000, check_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.pre_processing.preprocess_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the pre-processing operations described above.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y: ndarray</dt><dd><p>input movie (n_pixels x Time). Can be also memory mapped file.</p>
</dd>
<dt>n_processes: [optional] int</dt><dd><p>number of processes/threads to use concurrently</p>
</dd>
<dt>n_pixels_per_process: [optional] int</dt><dd><p>number of pixels to be simultaneously processed by each process</p>
</dd>
<dt>p: positive integer</dt><dd><p>order of AR process, default: 2</p>
</dd>
<dt>lags: positive integer</dt><dd><p>number of lags in the past to consider for determining time constants. Default 5</p>
</dd>
<dt>include_noise: Boolean</dt><dd><p>Flag to include pre-estimated noise value when determining time constants. Default: False</p>
</dd>
<dt>noise_range: np.ndarray [2 x 1] between 0 and 0.5</dt><dd><p>Range of frequencies compared to Nyquist rate over which the power spectrum is averaged
default: [0.25,0.5]</p>
</dd>
<dt>noise method: string</dt><dd><p>method of averaging the noise.
Choices:
‘mean’: Mean
‘median’: Median
‘logmexp’: Exponential of the mean of the logarithm of PSD (default)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Y: ndarray</dt><dd><p>movie preprocessed (n_pixels x Time). Can be also memory mapped file.</p>
</dd>
<dt>g:  np.ndarray (p x 1)</dt><dd><p>Discrete time constants</p>
</dd>
<dt>psx: ndarray</dt><dd><p>position of thoses pixels</p>
</dd>
<dt>sn_s: ndarray (memory mapped)</dt><dd><p>file where to store the results of computation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.initialization.initialize_components">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.initialization.</code><code class="sig-name descname">initialize_components</code><span class="sig-paren">(</span><em class="sig-param">Y, K=30, gSig=[5, 5], gSiz=None, ssub=1, tsub=1, nIter=5, maxIter=5, nb=1, kernel=None, use_hals=True, normalize_init=True, img=None, method_init='greedy_roi', max_iter_snmf=500, alpha_snmf=1000.0, sigma_smooth_snmf=(0.5, 0.5, 0.5), perc_baseline_snmf=20, options_local_NMF=None, rolling_sum=False, rolling_length=100, sn=None, options_total=None, min_corr=0.8, min_pnr=10, ring_size_factor=1.5, center_psf=False, ssub_B=2, init_iter=2, remove_baseline=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.initialization.initialize_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalize components</p>
<p>This method uses a greedy approach followed by hierarchical alternative least squares (HALS) NMF.
Optional use of spatio-temporal downsampling to boost speed.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>Y: np.ndarray</dt><dd><p>d1 x d2 [x d3] x T movie, raw data.</p>
</dd>
<dt>K: [optional] int</dt><dd><p>number of neurons to extract (default value: 30). Maximal number for method ‘corr_pnr’.</p>
</dd>
<dt>tau: [optional] list,tuple</dt><dd><p>standard deviation of neuron size along x and y [and z] (default value: (5,5).</p>
</dd>
<dt>gSiz: [optional] list,tuple</dt><dd><p>size of kernel (default 2*tau + 1).</p>
</dd>
<dt>nIter: [optional] int</dt><dd><p>number of iterations for shape tuning (default 5).</p>
</dd>
<dt>maxIter: [optional] int</dt><dd><p>number of iterations for HALS algorithm (default 5).</p>
</dd>
<dt>ssub: [optional] int</dt><dd><p>spatial downsampling factor recommended for large datasets (default 1, no downsampling).</p>
</dd>
<dt>tsub: [optional] int</dt><dd><p>temporal downsampling factor recommended for long datasets (default 1, no downsampling).</p>
</dd>
<dt>kernel: [optional] np.ndarray</dt><dd><p>User specified kernel for greedyROI
(default None, greedy ROI searches for Gaussian shaped neurons)</p>
</dd>
<dt>use_hals: [optional] bool</dt><dd><p>Whether to refine components with the hals method</p>
</dd>
<dt>normalize_init: [optional] bool</dt><dd><p>Whether to normalize_init data before running the initialization</p>
</dd>
<dt>img: optional [np 2d array]</dt><dd><p>Image with which to normalize. If not present use the mean + offset</p>
</dd>
<dt>method_init: str</dt><dd><p>Initialization method ‘greedy_roi’, ‘corr_pnr’. The latter can only be used for 2D data and it is compulsory for endoscopic one-photon data.</p>
</dd>
<dt>max_iter_snmf: int</dt><dd><p>Maximum number of sparse NMF iterations</p>
</dd>
<dt>alpha_snmf: scalar</dt><dd><p>Sparsity penalty</p>
</dd>
<dt>rolling_sum: boolean</dt><dd><p>Detect new components based on a rolling sum of pixel activity (default: True)</p>
</dd>
<dt>rolling_length: int</dt><dd><p>Length of rolling window (default: 100)</p>
</dd>
<dt>center_psf: Boolean</dt><dd><p>True indicates centering the filtering kernel for background
removal. This is useful for data with large background
fluctuations.</p>
</dd>
<dt>min_corr: float</dt><dd><p>minimum local correlation coefficients for selecting a seed pixel.</p>
</dd>
<dt>min_pnr: float</dt><dd><p>minimum peak-to-noise ratio for selecting a seed pixel.</p>
</dd>
<dt>ring_size_factor: float</dt><dd><p>it’s the ratio between the ring radius and neuron diameters.</p>
</dd>
<dt>nb: integer</dt><dd><p>number of background components for approximating the background using NMF model</p>
</dd>
<dt>sn: ndarray</dt><dd><p>per pixel noise</p>
</dd>
<dt>options_total: dict</dt><dd><p>the option dictionary</p>
</dd>
<dt>ssub_B: int, optional</dt><dd><p>downsampling factor for 1-photon imaging background computation</p>
</dd>
<dt>init_iter: int, optional</dt><dd><p>number of iterations for 1-photon imaging initialization</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Ain: np.ndarray</dt><dd><p>(d1 * d2 [ * d3]) x K , spatial filter of each neuron.</p>
</dd>
<dt>Cin: np.ndarray</dt><dd><p>T x K , calcium activity of each neuron.</p>
</dd>
<dt>center: np.ndarray</dt><dd><p>K x 2 [or 3] , inferred center of each neuron.</p>
</dd>
<dt>bin: np.ndarray</dt><dd><p>(d1 * d2 [ * d3]) x nb, initialization of spatial background.</p>
</dd>
<dt>fin: np.ndarray</dt><dd><p>nb x T matrix, initalization of temporal background</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>Exception “Unsupported method”</p>
<p>Exception ‘You need to define arguments for local NMF’</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="spatial-components">
<h2>Spatial Components<a class="headerlink" href="#spatial-components" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<code class="sig-name descname">update_spatial_components(Y, C=None, f=None, A_in=None, sn=None, dims=None, min_size=3, max_size=8, dist=3, normalize_yyt_one=True, method_exp='dilate', expandCore=None, dview=None, n_pixels_per_process=128, medw=(3, 3), thr_method='max', maxthr=0.1, nrgthr=0.9999, extract_cc=True, b_in=None, se=array([[1, 1, 1],</code></dt>
<dt>
<code class="sig-name descname">[1, 1, 1],</code></dt>
<dt>
<code class="sig-name descname">[1, 1, 1]]), ss=array([[1, 1, 1],</code></dt>
<dt>
<code class="sig-name descname">[1, 1, 1],</code></dt>
<dt>
<code class="sig-name descname">[1, 1, 1]]), nb=1, method_ls='lasso_lars', update_background_components=True, low_rank_background=True, block_size_spat=1000, num_blocks_per_run_spat=20)</code></dt>
<dd><p>update spatial footprints and background through Basis Pursuit Denoising</p>
<dl class="simple">
<dt>for each pixel i solve the problem</dt><dd><p>[A(i,:),b(i)] = argmin sum(A(i,:))</p>
</dd>
<dt>subject to</dt><dd><p>|| Y(i,:) - A(i,:)*C + b(i)*f || &lt;= sn(i)*sqrt(T);</p>
</dd>
</dl>
<p>for each pixel the search is limited to a few spatial components</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>Y: np.ndarray (2D or 3D)</dt><dd><p>movie, raw data in 2D or 3D (pixels x time).</p>
</dd>
<dt>C: np.ndarray</dt><dd><p>calcium activity of each neuron.</p>
</dd>
<dt>f: np.ndarray</dt><dd><p>temporal profile  of background activity.</p>
</dd>
<dt>A_in: np.ndarray</dt><dd><p>spatial profile of background activity. If A_in is boolean then it defines the spatial support of A.
Otherwise it is used to determine it through determine_search_location</p>
</dd>
<dt>b_in: np.ndarray</dt><dd><p>you can pass background as input, especially in the case of one background per patch, since it will update using hals</p>
</dd>
<dt>dims: [optional] tuple</dt><dd><p>x, y[, z] movie dimensions</p>
</dd>
</dl>
<p>min_size: [optional] int</p>
<p>max_size: [optional] int</p>
<p>dist: [optional] int</p>
<dl class="simple">
<dt>sn: [optional] float</dt><dd><p>noise associated with each pixel if known</p>
</dd>
<dt>backend [optional] str</dt><dd><p>‘ipyparallel’, ‘single_thread’
single_thread:no parallelization. It can be used with small datasets.
ipyparallel: uses ipython clusters and then send jobs to each of them
SLURM: use the slurm scheduler</p>
</dd>
<dt>n_pixels_per_process: [optional] int</dt><dd><p>number of pixels to be processed by each thread</p>
</dd>
<dt>method: [optional] string</dt><dd><p>method used to expand the search for pixels ‘ellipse’ or ‘dilate’</p>
</dd>
<dt>expandCore: [optional]  scipy.ndimage.morphology</dt><dd><p>if method is dilate this represents the kernel used for expansion</p>
</dd>
<dt>dview: view on ipyparallel client</dt><dd><p>you need to create an ipyparallel client and pass a view on the processors (client = Client(), dview=client[:])</p>
</dd>
<dt>medw, thr_method, maxthr, nrgthr, extract_cc, se, ss: [optional]</dt><dd><p>Parameters for components post-processing. Refer to spatial.threshold_components for more details</p>
</dd>
<dt>nb: [optional] int</dt><dd><p>Number of background components</p>
</dd>
<dt>method_ls:</dt><dd><dl class="simple">
<dt>method to perform the regression for the basis pursuit denoising.</dt><dd><p>‘nnls_L0’. Nonnegative least square with L0 penalty
‘lasso_lars’ lasso lars function from scikit learn</p>
</dd>
<dt>normalize_yyt_one: bool</dt><dd><p>wheter to norrmalize the C and A matrices so that diag(C*C.T) are ones</p>
</dd>
</dl>
</dd>
<dt>update_background_components:bool</dt><dd><p>whether to update the background components in the spatial phase</p>
</dd>
<dt>low_rank_background:bool</dt><dd><p>whether to update the using a low rank approximation. In the False case all the nonzero elements of the background components are updated using hals
(to be used with one background per patch)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>A: np.ndarray</dt><dd><p>new estimate of spatial footprints</p>
</dd>
<dt>b: np.ndarray</dt><dd><p>new estimate of spatial background</p>
</dd>
<dt>C: np.ndarray</dt><dd><p>temporal components (updated only when spatial components are completely removed)</p>
</dd>
<dt>f: np.ndarray</dt><dd><p>same as f_in except if empty component deleted.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>Exception ‘You need to define the input dimensions’</p>
<p>Exception ‘Dimension of Matrix Y must be pixels x time’</p>
<p>Exception ‘Dimension of Matrix C must be neurons x time’</p>
<p>Exception ‘Dimension of Matrix f must be background comps x time ‘</p>
<p>Exception ‘Either A or C need to be determined’</p>
<p>Exception ‘Dimension of Matrix A must be pixels x neurons’</p>
<p>Exception ‘You need to provide estimate of C and f’</p>
<p>Exception ‘Not implemented consistently’</p>
<p>Exception “Failed to delete: ” + folder</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="temporal-components">
<h2>Temporal Components<a class="headerlink" href="#temporal-components" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.temporal.update_temporal_components">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.temporal.</code><code class="sig-name descname">update_temporal_components</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">A</em>, <em class="sig-param">b</em>, <em class="sig-param">Cin</em>, <em class="sig-param">fin</em>, <em class="sig-param">bl=None</em>, <em class="sig-param">c1=None</em>, <em class="sig-param">g=None</em>, <em class="sig-param">sn=None</em>, <em class="sig-param">nb=1</em>, <em class="sig-param">ITER=2</em>, <em class="sig-param">block_size_temp=5000</em>, <em class="sig-param">num_blocks_per_run_temp=20</em>, <em class="sig-param">debug=False</em>, <em class="sig-param">dview=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.temporal.update_temporal_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Update temporal components and background given spatial components using a block coordinate descent approach.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y: np.ndarray (2D)</dt><dd><p>input data with time in the last axis (d x T)</p>
</dd>
<dt>A: sparse matrix (crc format)</dt><dd><p>matrix of temporal components (d x K)</p>
</dd>
<dt>b: ndarray (dx1)</dt><dd><p>current estimate of background component</p>
</dd>
<dt>Cin: np.ndarray</dt><dd><p>current estimate of temporal components (K x T)</p>
</dd>
<dt>fin: np.ndarray</dt><dd><p>current estimate of temporal background (vector of length T)</p>
</dd>
<dt>g:  np.ndarray</dt><dd><p>Global time constant (not used)</p>
</dd>
<dt>bl: np.ndarray</dt><dd><p>baseline for fluorescence trace for each column in A</p>
</dd>
<dt>c1: np.ndarray</dt><dd><p>initial concentration for each column in A</p>
</dd>
<dt>g:  np.ndarray</dt><dd><p>discrete time constant for each column in A</p>
</dd>
<dt>sn: np.ndarray</dt><dd><p>noise level for each column in A</p>
</dd>
<dt>nb: [optional] int</dt><dd><p>Number of background components</p>
</dd>
<dt>ITER: positive integer</dt><dd><p>Maximum number of block coordinate descent loops.</p>
</dd>
<dt>method_foopsi: string</dt><dd><p>Method of deconvolution of neural activity. constrained_foopsi is the only method supported at the moment.</p>
</dd>
<dt>n_processes: int</dt><dd><dl class="simple">
<dt>number of processes to use for parallel computation.</dt><dd><p>Should be less than the number of processes started with ipcluster.</p>
</dd>
</dl>
</dd>
<dt>backend: ‘str’</dt><dd><p>single_thread no parallelization
ipyparallel, parallelization using the ipyparallel cluster.
You should start the cluster (install ipyparallel and then type
ipcluster -n 6, where 6 is the number of processes).
SLURM: using SLURM scheduler</p>
</dd>
<dt>memory_efficient: Bool</dt><dd><p>whether or not to optimize for memory usage (longer running times). necessary with very large datasets</p>
</dd>
<dt>kwargs: dict</dt><dd><dl class="simple">
<dt>all parameters passed to constrained_foopsi except bl,c1,g,sn (see documentation).</dt><dd><p>Some useful parameters are</p>
</dd>
</dl>
</dd>
<dt>p: int</dt><dd><p>order of the autoregression model</p>
</dd>
<dt>method: [optional] string</dt><dd><dl class="simple">
<dt>solution method for constrained foopsi. Choices are</dt><dd><p>‘cvx’:      using cvxopt and picos (slow especially without the MOSEK solver)
‘cvxpy’:    using cvxopt and cvxpy with the ECOS solver (faster, default)</p>
</dd>
</dl>
</dd>
<dt>solvers: list string</dt><dd><dl class="simple">
<dt>primary and secondary (if problem unfeasible for approx solution)</dt><dd><p>solvers to be used with cvxpy, default is [‘ECOS’,’SCS’]</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Note:</dt><dd><p>The temporal components are updated in parallel by default by forming of sequence of vertex covers.</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>C:   np.ndarray</dt><dd><p>matrix of temporal components (K x T)</p>
</dd>
<dt>f:   np.array</dt><dd><p>vector of temporal background (length T)</p>
</dd>
<dt>S:   np.ndarray</dt><dd><p>matrix of merged deconvolved activity (spikes) (K x T)</p>
</dd>
<dt>bl:  float</dt><dd><p>same as input</p>
</dd>
<dt>c1:  float</dt><dd><p>same as input</p>
</dd>
<dt>g:   float</dt><dd><p>same as input</p>
</dd>
<dt>sn:  float</dt><dd><p>same as input</p>
</dd>
<dt>YrA: np.ndarray</dt><dd><p>matrix of spatial component filtered raw data, after all contributions have been removed.
YrA corresponds to the residual trace for each component and is used for faster plotting (K x T)</p>
</dd>
<dt>lam: np.ndarray</dt><dd><p>Automatically tuned sparsity parameter</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="merge-components">
<h2>Merge components<a class="headerlink" href="#merge-components" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.merging.merge_components">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.merging.</code><code class="sig-name descname">merge_components</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">A</em>, <em class="sig-param">b</em>, <em class="sig-param">C</em>, <em class="sig-param">f</em>, <em class="sig-param">S</em>, <em class="sig-param">sn_pix</em>, <em class="sig-param">temporal_params</em>, <em class="sig-param">spatial_params</em>, <em class="sig-param">dview=None</em>, <em class="sig-param">thr=0.85</em>, <em class="sig-param">fast_merge=True</em>, <em class="sig-param">mx=1000</em>, <em class="sig-param">bl=None</em>, <em class="sig-param">c1=None</em>, <em class="sig-param">sn=None</em>, <em class="sig-param">g=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.merging.merge_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Merging of spatially overlapping components that have highly correlated temporal activity</p>
<p>The correlation threshold for merging overlapping components is user specified in thr</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Y: np.ndarray</dt><dd><p>residual movie after subtracting all found components (Y_res = Y - A*C - b*f) (d x T)</p>
</dd>
<dt>A: sparse matrix</dt><dd><p>matrix of spatial components (d x K)</p>
</dd>
<dt>b: np.ndarray</dt><dd><p>spatial background (vector of length d)</p>
</dd>
<dt>C: np.ndarray</dt><dd><p>matrix of temporal components (K x T)</p>
</dd>
<dt>f:     np.ndarray</dt><dd><p>temporal background (vector of length T)</p>
</dd>
<dt>S:     np.ndarray</dt><dd><p>matrix of deconvolved activity (spikes) (K x T)</p>
</dd>
<dt>sn_pix: ndarray</dt><dd><p>noise standard deviation for each pixel</p>
</dd>
<dt>temporal_params: dictionary</dt><dd><p>all the parameters that can be passed to the update_temporal_components function</p>
</dd>
<dt>spatial_params: dictionary</dt><dd><p>all the parameters that can be passed to the update_spatial_components function</p>
</dd>
<dt>thr:   scalar between 0 and 1</dt><dd><p>correlation threshold for merging (default 0.85)</p>
</dd>
<dt>mx:    int</dt><dd><p>maximum number of merging operations (default 50)</p>
</dd>
<dt>sn_pix:    nd.array</dt><dd><p>noise level for each pixel (vector of length d)</p>
</dd>
<dt>fast_merge: bool</dt><dd><p>if true perform rank 1 merging, otherwise takes best neuron</p>
</dd>
<dt>bl:</dt><dd><p>baseline for fluorescence trace for each row in C</p>
</dd>
<dt>c1:</dt><dd><p>initial concentration for each row in C</p>
</dd>
<dt>g:</dt><dd><p>discrete time constant for each row in C</p>
</dd>
<dt>sn:</dt><dd><p>noise level for each row in C</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>A:     sparse matrix</dt><dd><p>matrix of merged spatial components (d x K)</p>
</dd>
<dt>C:     np.ndarray</dt><dd><p>matrix of merged temporal components (K x T)</p>
</dd>
<dt>nr:    int</dt><dd><p>number of components after merging</p>
</dd>
<dt>merged_ROIs: list</dt><dd><p>index of components that have been merged</p>
</dd>
<dt>S:     np.ndarray</dt><dd><p>matrix of merged deconvolved activity (spikes) (K x T)</p>
</dd>
<dt>bl: float</dt><dd><p>baseline for fluorescence trace</p>
</dd>
<dt>c1: float</dt><dd><p>initial concentration</p>
</dd>
<dt>g:  float</dt><dd><p>discrete time constant</p>
</dd>
<dt>sn: float</dt><dd><p>noise level</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><p>Exception “The number of elements of blc1gsn must match the number of components”</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.utilities.detrend_df_f">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.utilities.</code><code class="sig-name descname">detrend_df_f</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">b</em>, <em class="sig-param">C</em>, <em class="sig-param">f</em>, <em class="sig-param">YrA=None</em>, <em class="sig-param">quantileMin=8</em>, <em class="sig-param">frames_window=500</em>, <em class="sig-param">flag_auto=True</em>, <em class="sig-param">use_fast=False</em>, <em class="sig-param">detrend_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.utilities.detrend_df_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute DF/F signal without using the original data.
In general much faster than extract_DF_F</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>A: scipy.sparse.csc_matrix</dt><dd><p>spatial components (from cnmf cnm.A)</p>
</dd>
<dt>b: ndarray</dt><dd><p>spatial background components</p>
</dd>
<dt>C: ndarray</dt><dd><p>temporal components (from cnmf cnm.C)</p>
</dd>
<dt>f: ndarray</dt><dd><p>temporal background components</p>
</dd>
<dt>YrA: ndarray</dt><dd><p>residual signals</p>
</dd>
<dt>quantile_min: float</dt><dd><p>quantile used to estimate the baseline (values in [0,100])</p>
</dd>
<dt>frames_window: int</dt><dd><p>number of frames for computing running quantile</p>
</dd>
<dt>flag_auto: bool</dt><dd><p>flag for determining quantile automatically</p>
</dd>
<dt>use_fast: bool</dt><dd><p>flag for u´sing approximate fast percentile filtering</p>
</dd>
<dt>detrend_only: bool (False)</dt><dd><p>flag for only subtracting baseline and not normalizing by it.
Used in 1p data processing where baseline fluorescence cannot be
determined.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>F_df:</dt><dd><p>the computed Calcium acitivty to the derivative of f</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.utilities.update_order">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.utilities.</code><code class="sig-name descname">update_order</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">new_a=None</em>, <em class="sig-param">prev_list=None</em>, <em class="sig-param">method='greedy'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.utilities.update_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the update order of the temporal components given the spatial
components by creating a nest of random approximate vertex covers</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>A:    np.ndarray</dt><dd><p>matrix of spatial components (d x K)</p>
</dd>
<dt>new_a: sparse array</dt><dd><p>spatial component that is added, in order to efficiently update the orders in online scenarios</p>
</dd>
<dt>prev_list: list of list</dt><dd><p>orders from previous iteration, you need to pass if new_a is not None</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>O:  list of sets</dt><dd><p>list of subsets of components. The components of each subset can be updated in parallel</p>
</dd>
<dt>lo: list</dt><dd><p>length of each subset</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Written by Eftychios A. Pnevmatikakis, Simons Foundation, 2015</p>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.utilities.get_file_size">
<code class="sig-prename descclassname">caiman.source_extraction.cnmf.utilities.</code><code class="sig-name descname">get_file_size</code><span class="sig-paren">(</span><em class="sig-param">file_name</em>, <em class="sig-param">var_name_hdf5='mov'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.utilities.get_file_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the dimensions of a file or a list of files without loading
it/them in memory. An exception is thrown if the files have FOVs with
different sizes</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name: str or list</dt><dd><p>locations of file(s) in memory</p>
</dd>
<dt>var_name_hdf5: ‘str’</dt><dd><p>if loading from hdf5 name of the variable to load</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dims: list</dt><dd><p>dimensions of FOV</p>
</dd>
<dt>T: list</dt><dd><p>number of timesteps in each file</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="parallel-processing-functions">
<h2>Parallel Processing functions<a class="headerlink" href="#parallel-processing-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.cluster.apply_to_patch">
<code class="sig-prename descclassname">caiman.cluster.</code><code class="sig-name descname">apply_to_patch</code><span class="sig-paren">(</span><em class="sig-param">mmap_file, shape:Tuple[Any, Any, Any], dview, rf, stride, function, *args, **kwargs</em><span class="sig-paren">)</span> &#x2192; Tuple[List, Any, Tuple]<a class="headerlink" href="#caiman.cluster.apply_to_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>apply function to patches in parallel or not</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mmap_file: Memory-mapped variable</dt><dd><p>Variable handle, first thing returned by load_memmap()</p>
</dd>
<dt>shape: tuple of three elements</dt><dd><p>dimensions of the original movie across y, x, and time</p>
</dd>
<dt>dview: ipyparallel view on client</dt><dd><p>if None</p>
</dd>
<dt>rf: int</dt><dd><p>half-size of the square patch in pixel</p>
</dd>
<dt>stride: int</dt><dd><p>amount of overlap between patches</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>results</p>
</dd>
<dt>Raises:</dt><dd><p>Exception ‘Something went wrong’</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.cluster.start_server">
<code class="sig-prename descclassname">caiman.cluster.</code><code class="sig-name descname">start_server</code><span class="sig-paren">(</span><em class="sig-param">slurm_script:str=None</em>, <em class="sig-param">ipcluster:str='ipcluster'</em>, <em class="sig-param">ncpus:int=None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#caiman.cluster.start_server" title="Permalink to this definition">¶</a></dt>
<dd><p>programmatically start the ipyparallel server</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ncpus: int</dt><dd><p>number of processors</p>
</dd>
<dt>ipcluster<span class="classifier">str</span></dt><dd><p>ipcluster binary file name; requires 4 path separators on Windows. ipcluster=”C:\Anaconda2\Scripts\ipcluster.exe”
Default: “ipcluster”</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.cluster.stop_server">
<code class="sig-prename descclassname">caiman.cluster.</code><code class="sig-name descname">stop_server</code><span class="sig-paren">(</span><em class="sig-param">ipcluster:str='ipcluster'</em>, <em class="sig-param">pdir:str=None</em>, <em class="sig-param">profile:str=None</em>, <em class="sig-param">dview=None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#caiman.cluster.stop_server" title="Permalink to this definition">¶</a></dt>
<dd><p>programmatically stops the ipyparallel server</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>ipcluster<span class="classifier">str</span></dt><dd><p>ipcluster binary file name; requires 4 path separators on Windows
Default: “ipcluster”a</p>
</dd>
</dl>
<p>pdir : Undocumented
profile: Undocumented
dview: Undocumented</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Core Functions</a><ul>
<li><a class="reference internal" href="#movie-handling">Movie Handling</a></li>
<li><a class="reference internal" href="#timeseries-handling">Timeseries Handling</a></li>
<li><a class="reference internal" href="#rois">ROIs</a></li>
<li><a class="reference internal" href="#memory-mapping">Memory mapping</a></li>
<li><a class="reference internal" href="#image-statistics">Image statistics</a></li>
<li><a class="reference internal" href="#motion-correction">Motion Correction</a></li>
<li><a class="reference internal" href="#estimates">Estimates</a></li>
<li><a class="reference internal" href="#deconvolution">Deconvolution</a></li>
<li><a class="reference internal" href="#parameter-setting">Parameter Setting</a></li>
<li><a class="reference internal" href="#cnmf">CNMF</a></li>
<li><a class="reference internal" href="#online-cnmf-onacid">Online CNMF (OnACID)</a></li>
<li><a class="reference internal" href="#preprocessing">Preprocessing</a></li>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#spatial-components">Spatial Components</a></li>
<li><a class="reference internal" href="#temporal-components">Temporal Components</a></li>
<li><a class="reference internal" href="#merge-components">Merge components</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
<li><a class="reference internal" href="#parallel-processing-functions">Parallel Processing functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Getting_Started.html"
                        title="previous chapter">Demos</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/core_functions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Getting_Started.html" title="Demos"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CaImAn 1.4 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Flatiron Institute, Simons Foundation, New York, NY.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.0.
    </div>
  </body>
</html>