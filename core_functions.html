
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Core Functions &#8212; Constrained NMF 0.0.4 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Overview" href="Overview.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Overview.html" title="Overview"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Constrained NMF 0.0.4 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="core-functions">
<h1>Core Functions<a class="headerlink" href="#core-functions" title="Permalink to this headline">¶</a></h1>
<p>Functions that are required to operate the package at a basic level</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.CNMF</span></code>(n_processes)</td>
<td>Source extraction using constrained non-negative matrix factorization.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.CNMF.fit</span></code>(images)</td>
<td>This method uses the cnmf algorithm to find sources in data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID" title="caiman.source_extraction.cnmf.online_cnmf.OnACID"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.online_cnmf.OnACID</span></code></a>([…])</td>
<td>Source extraction of streaming data using online matrix factorization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online</span></code></a>(…)</td>
<td>Implements the caiman online algorithm on the list of files fls.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.params.CNMFParams.__init__</span></code>([…])</td>
<td>Class for setting the processing parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates" title="caiman.source_extraction.cnmf.estimates.Estimates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.source_extraction.cnmf.estimates.Estimates</span></code></a>([…])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.motion_correction.MotionCorrect" title="caiman.motion_correction.MotionCorrect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.motion_correction.MotionCorrect</span></code></a>(fname)</td>
<td>class implementing motion correction operations</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct" title="caiman.motion_correction.MotionCorrect.motion_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.motion_correction.MotionCorrect.motion_correct</span></code></a>([…])</td>
<td>general function for performing all types of motion correction.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.base.movies.load" title="caiman.base.movies.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.movies.load</span></code></a>(file_name[,&nbsp;fr,&nbsp;…])</td>
<td>load movie from file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.base.movies.movie.play" title="caiman.base.movies.movie.play"><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.movies.movie.play</span></code></a>([gain,&nbsp;fr,&nbsp;…])</td>
<td>Play the movie using opencv</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.rois.register_ROIs</span></code>(A1,&nbsp;A2,&nbsp;dims)</td>
<td>Register ROIs across different sessions using an intersection over union  metric and the Hungarian algorithm for optimal matching</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">caiman.base.rois.register_multisession</span></code>(A,&nbsp;dims)</td>
<td>Register ROIs across multiple sessions using an intersection over union metric and the Hungarian algorithm for optimal matching.</td>
</tr>
</tbody>
</table>
<div class="section" id="movie-handling">
<h2>Movie Handling<a class="headerlink" href="#movie-handling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.base.movies.movie">
<em class="property">class </em><code class="descclassname">caiman.base.movies.</code><code class="descname">movie</code><a class="headerlink" href="#caiman.base.movies.movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a movie. This class subclasses timeseries,
that in turn subclasses ndarray</p>
<p>movie(input_arr, fr=None,start_time=0,file_name=None, meta_data=None)</p>
<dl class="docutils">
<dt>Example of usage:</dt>
<dd>input_arr = 3d ndarray
fr=33; # 33 Hz
start_time=0
m=movie(input_arr, start_time=0,fr=33);</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt>
<dd><p class="first last">Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd><p class="first last">Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt>
<dd><p class="first last">An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd><p class="first last">Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd><p class="first last">Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first last">Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt>
<dd><p class="first last">A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt>
<dd><p class="first last">The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt>
<dd><p class="first last">Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt>
<dd><p class="first last">Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt>
<dd><p class="first last">Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt>
<dd><p class="first last">The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt>
<dd><p class="first last">Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd><p class="first last">Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt>
<dd><p class="first last">Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
<dt><strong>time</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA</span></code>([components,&nbsp;batch])</td>
<td>Iterative Principal Component analysis, see sklearn.decomposition.incremental_pca</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA_denoise</span></code>([components,&nbsp;batch])</td>
<td>Create a denoised version of the movie using only the first ‘components’ components</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA_io</span></code>([n_components,&nbsp;fun,&nbsp;max_iter,&nbsp;tol])</td>
<td>DO NOT USE STILL UNDER DEVELOPMENT</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">IPCA_stICA</span></code>([componentsPCA,&nbsp;componentsICA,&nbsp;…])</td>
<td>Compute PCA + ICA a la Mukamel 2009.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">NonnegativeMatrixFactorization</span></code>([…])</td>
<td>See documentation for scikit-learn NMF</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if all elements evaluate to True.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if any of the elements of <cite>a</cite> evaluate to True.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_shifts</span></code>(shifts[,&nbsp;interpolation,&nbsp;…])</td>
<td>Apply precomputed shifts to a movie, using subpixels adjustment (cv2.INTER_CUBIC function)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis,&nbsp;out])</td>
<td>Return indices of the maximum values along the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis,&nbsp;out])</td>
<td>Return indices of the minimum values along the given axis of <cite>a</cite>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would partition this array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would sort this array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[,&nbsp;order,&nbsp;casting,&nbsp;subok,&nbsp;copy])</td>
<td>Copy of the array, cast to a specified type.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">bilateral_blur_2D</span></code>([diameter,&nbsp;sigmaColor,&nbsp;…])</td>
<td>performs bilateral filtering on each frame.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin_median</span></code>([window])</td>
<td>compute median of 3D array in along axis o by binning values</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>(inplace)</td>
<td>Swap the bytes of the array elements</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[,&nbsp;out,&nbsp;mode])</td>
<td>Use an index array to construct a new array from a set of choices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min,&nbsp;max,&nbsp;out])</td>
<td>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[,&nbsp;axis,&nbsp;out])</td>
<td>Return selected slices of this array along given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.base.movies.movie.computeDFF" title="caiman.base.movies.movie.computeDFF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">computeDFF</span></code></a>([secsWindow,&nbsp;quantilMin,&nbsp;method,&nbsp;…])</td>
<td>compute the DFF of the movie or remove baseline</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</td>
<td>Complex-conjugate all elements.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</td>
<td>Return a copy of the array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code>([crop_top,&nbsp;crop_bottom,&nbsp;crop_left,&nbsp;…])</td>
<td>Crop movie</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative product of the elements along the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative sum of the elements along the given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">debleach</span></code>()</td>
<td>Debleach by fiting a model to the median intensity.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset,&nbsp;axis1,&nbsp;axis2])</td>
<td>Return specified diagonals.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</td>
<td>Dump a pickle of the array to the specified file.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</td>
<td>Returns the pickle of the array as a string.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_shifts</span></code>([max_shift_w,&nbsp;max_shift_h,&nbsp;…])</td>
<td>Performs motion corretion using the opencv matchtemplate function.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_traces_from_masks</span></code>(masks)</td>
<td>Args:     masks: array, 3D with each 2D slice bein a mask (integer or fractional)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</td>
<td>Fill the array with a scalar value.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</td>
<td>Return a copy of the array collapsed into one dimension.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian_blur_2D</span></code>([kernel_size_x,&nbsp;…])</td>
<td>Compute gaussian blut in 2D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[,&nbsp;offset])</td>
<td>Returns a field of the given array as a certain type.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">guided_filter_blur_2D</span></code>(guide_filter[,&nbsp;…])</td>
<td>performs guided filtering on each frame.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</td>
<td>Copy an element of an array to a standard Python scalar and return it.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</td>
<td>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">local_correlations</span></code>([eight_neighbours,&nbsp;…])</td>
<td>Computes the correlation image for the input dataset Y</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code>([axis,&nbsp;out])</td>
<td>Return the maximum along a given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns the average of the array elements along given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">median_blur_2D</span></code>([kernel_size])</td>
<td>Compute gaussian blut in 2D.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the minimum along a given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct</span></code>([max_shift_w,&nbsp;max_shift_h,&nbsp;…])</td>
<td>Extract shifts and motion corrected movie automatically,</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</td>
<td>Return the array with the same data viewed with a different byte order.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</td>
<td>Return the indices of the elements that are non-zero.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">online_NMF</span></code>([n_components,&nbsp;method,&nbsp;lambda1,&nbsp;…])</td>
<td>Method performing online matrix factorization and using the spams</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Rearranges the elements in the array in such a way that value of the element in kth position is in the position it would be in a sorted array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_FOV_KMeans</span></code>([tradeoff_weight,&nbsp;fx,&nbsp;…])</td>
<td>Partition the FOV in clusters that are grouping pixels close in space and in mutual correlation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.base.movies.movie.play" title="caiman.base.movies.movie.play"><code class="xref py py-obj docutils literal notranslate"><span class="pre">play</span></code></a>([gain,&nbsp;fr,&nbsp;magnification,&nbsp;offset,&nbsp;…])</td>
<td>Play the movie using opencv</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the product of the array elements over the given axis</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code>([axis,&nbsp;out])</td>
<td>Peak to peak (maximum - minimum) value along a given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices,&nbsp;values[,&nbsp;mode])</td>
<td>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</td>
<td>Return a flattened array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[,&nbsp;axis])</td>
<td>Repeat elements of an array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[,&nbsp;order])</td>
<td>Returns an array containing the same data with a new shape.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.base.movies.movie.resize" title="caiman.base.movies.movie.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a>(new_shape[,&nbsp;refcheck])</td>
<td>Change shape and size of array in-place.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals,&nbsp;out])</td>
<td>Return <cite>a</cite> with each element rounded to the given number of decimals.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code>(file_name[,&nbsp;to32,&nbsp;order,&nbsp;imagej,&nbsp;…])</td>
<td>Save the timeseries in various formats</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[,&nbsp;side,&nbsp;sorter])</td>
<td>Find indices where elements of v should be inserted in a to maintain order.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val,&nbsp;dtype[,&nbsp;offset])</td>
<td>Put a value into a specified place in a field defined by a data-type.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write,&nbsp;align,&nbsp;uic])</td>
<td>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Sort an array, in-place.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</td>
<td>Remove single-dimensional entries from the shape of <cite>a</cite>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the standard deviation of the array elements along given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the sum of the array elements over the given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1,&nbsp;axis2)</td>
<td>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[,&nbsp;axis,&nbsp;out,&nbsp;mode])</td>
<td>Return an array formed from the elements of <cite>a</cite> at the given indices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</td>
<td>Construct Python bytes containing the raw data bytes in the array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[,&nbsp;sep,&nbsp;format])</td>
<td>Write array to a file as text or binary (default).</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</td>
<td>Return the array as a (possibly nested) list.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</td>
<td>Construct Python bytes containing the raw data bytes in the array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset,&nbsp;axis1,&nbsp;axis2,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum along diagonals of the array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</td>
<td>Returns a view of the array with axes transposed.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the variance of the array elements, along given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype,&nbsp;type])</td>
<td>New view of array with the same data.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">zproject</span></code>([method,&nbsp;cmap,&nbsp;aspect])</td>
<td>Compute and plot projection across time:</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="74%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>apply_shifts_online</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>calc_min</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>motion_correction_online</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>resample</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>to_2D</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.base.movies.movie.play">
<code class="descclassname">movie.</code><code class="descname">play</code><span class="sig-paren">(</span><em>gain=1</em>, <em>fr=None</em>, <em>magnification=1</em>, <em>offset=0</em>, <em>interpolation=1</em>, <em>backend='opencv'</em>, <em>do_loop=False</em>, <em>bord_px=None</em>, <em>q_max=100</em>, <em>q_min=0</em>, <em>plot_text=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.movies.movie.play" title="Permalink to this definition">¶</a></dt>
<dd><p>Play the movie using opencv</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">gain: adjust  movie brightness</p>
<p>frate : playing speed if different from original (inter frame interval in seconds)</p>
<p class="last">backend: ‘pylab’ or ‘opencv’, the latter much faster</p>
</dd>
<dt>Raises:</dt>
<dd>Exception ‘Unknown backend!’</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.base.movies.movie.resize">
<code class="descclassname">movie.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>new_shape</em>, <em>refcheck=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.movies.movie.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Change shape and size of array in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>new_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of ints, or <cite>n</cite> ints</span></dt>
<dd><p class="first last">Shape of resized array.</p>
</dd>
<dt><strong>refcheck</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If False, reference count will not be checked. Default is True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>None</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">If <cite>a</cite> does not own its own data or references or views to it exist,
and the data memory must be changed.
PyPy only: will always raise if the data memory must be changed, since
there is no reliable way to determine if references or views to it
exist.</p>
</dd>
<dt><strong>SystemError</strong></dt>
<dd><p class="first last">If the <cite>order</cite> keyword argument is specified. This behaviour is a
bug in NumPy.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#caiman.base.movies.movie.resize" title="caiman.base.movies.movie.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a></dt>
<dd>Return a new array with the specified shape.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This reallocates space for the data area if necessary.</p>
<p>Only contiguous arrays (data elements consecutive in memory) can be
resized.</p>
<p>The purpose of the reference count check is to make sure you
do not use this array as a buffer for another Python object and then
reallocate the memory. However, reference counts can increase in
other ways so if you are sure that you have not shared the memory
for this array with another Python object, then you may safely set
<cite>refcheck</cite> to False.</p>
<p class="rubric">Examples</p>
<p>Shrinking an array: array is flattened (in the order that the data are
stored in memory), resized, and reshaped:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [1]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0],</span>
<span class="go">       [2]])</span>
</pre></div>
</div>
<p>Enlarging an array: as above, but missing entries are filled with zeros:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># new_shape parameter doesn&#39;t have to be a tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 0, 0]])</span>
</pre></div>
</div>
<p>Referencing an array prevents resizing…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot resize an array that has been referenced ...</span>
</pre></div>
</div>
<p>Unless <cite>refcheck</cite> is False:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="caiman.base.movies.movie.computeDFF">
<code class="descclassname">movie.</code><code class="descname">computeDFF</code><span class="sig-paren">(</span><em>secsWindow=5</em>, <em>quantilMin=8</em>, <em>method='only_baseline'</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.movies.movie.computeDFF" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the DFF of the movie or remove baseline</p>
<p>In order to compute the baseline frames are binned according to the window length parameter
and then the intermediate values are interpolated.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">secsWindow: length of the windows used to compute the quantile</p>
<p>quantilMin : value of the quantile</p>
<p class="last">method=’only_baseline’,’delta_f_over_f’,’delta_f_over_sqrt_f’</p>
</dd>
<dt>Returns:</dt>
<dd><p class="first">self: DF or DF/F or DF/sqrt(F) movies</p>
<p class="last">movBL=baseline movie</p>
</dd>
<dt>Raises:</dt>
<dd>Exception ‘Unknown method’</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.movies.load">
<code class="descclassname">caiman.base.movies.</code><code class="descname">load</code><span class="sig-paren">(</span><em>file_name</em>, <em>fr=30</em>, <em>start_time=0</em>, <em>meta_data=None</em>, <em>subindices=None</em>, <em>shape=None</em>, <em>var_name_hdf5='mov'</em>, <em>in_memory=False</em>, <em>is_behavior=False</em>, <em>bottom=0</em>, <em>top=0</em>, <em>left=0</em>, <em>right=0</em>, <em>channel=None</em>, <em>outtype=&lt;class 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.movies.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load movie from file. SUpports a variety of formats. tif, hdf5, npy and memory mapped. Matlab is experimental.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_name: string</dt>
<dd>name of file. Possible extensions are tif, avi, npy, (npz and hdf5 are usable only if saved by calblitz)</dd>
<dt>fr: float</dt>
<dd>frame rate</dd>
<dt>start_time: float</dt>
<dd>initial time for frame 1</dd>
<dt>meta_data: dict</dt>
<dd>dictionary containing meta information about the movie</dd>
<dt>subindices: iterable indexes</dt>
<dd>for loading only portion of the movie</dd>
<dt>shape: tuple of two values</dt>
<dd>dimension of the movie along x and y if loading from a two dimensional numpy array</dd>
<dt>num_frames_sub_idx:</dt>
<dd>when reading sbx format (experimental and unstable)</dd>
<dt>var_name_hdf5: str</dt>
<dd>if loading from hdf5 name of the variable to load</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>mov: caiman.movie</dd>
<dt>Raises:</dt>
<dd><p class="first">Exception ‘Subindices not implemented’</p>
<p>Exception ‘Subindices not implemented’</p>
<p>Exception ‘sima module unavailable’</p>
<p>Exception ‘Unknown file type’</p>
<p class="last">Exception ‘File not found!’</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.movies.load_movie_chain">
<code class="descclassname">caiman.base.movies.</code><code class="descname">load_movie_chain</code><span class="sig-paren">(</span><em>file_list</em>, <em>fr=30</em>, <em>start_time=0</em>, <em>meta_data=None</em>, <em>subindices=None</em>, <em>bottom=0</em>, <em>top=0</em>, <em>left=0</em>, <em>right=0</em>, <em>z_top=0</em>, <em>z_bottom=0</em>, <em>is3D=False</em>, <em>channel=None</em>, <em>outtype=&lt;class 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.movies.load_movie_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>load movies from list of file names</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>file_list: list</dt>
<dd>file names in string format</dd>
</dl>
<p>the other parameters as in load_movie except</p>
<dl class="last docutils">
<dt>bottom, top, left, right, z_top, z_bottom <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>to load only portion of the field of view</dd>
<dt>is3D <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>flag for 3d data (adds a fourth dimension)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>movie: cm.movie</dt>
<dd>movie corresponding to the concatenation og the input files</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="timeseries-handling">
<h2>Timeseries Handling<a class="headerlink" href="#timeseries-handling" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.base.timeseries.timeseries">
<em class="property">class </em><code class="descclassname">caiman.base.timeseries.</code><code class="descname">timeseries</code><a class="headerlink" href="#caiman.base.timeseries.timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing a time series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt>
<dd><p class="first last">Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt>
<dd><p class="first last">Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt>
<dd><p class="first last">An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt>
<dd><p class="first last">Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt>
<dd><p class="first last">Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt>
<dd><p class="first last">Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt>
<dd><p class="first last">A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt>
<dd><p class="first last">The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt>
<dd><p class="first last">Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt>
<dd><p class="first last">Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt>
<dd><p class="first last">Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt>
<dd><p class="first last">The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt>
<dd><p class="first last">Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd><p class="first last">Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt>
<dd><p class="first last">Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
<dt><strong>time</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if all elements evaluate to True.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if any of the elements of <cite>a</cite> evaluate to True.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code>([axis,&nbsp;out])</td>
<td>Return indices of the maximum values along the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code>([axis,&nbsp;out])</td>
<td>Return indices of the minimum values along the given axis of <cite>a</cite>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would partition this array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would sort this array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[,&nbsp;order,&nbsp;casting,&nbsp;subok,&nbsp;copy])</td>
<td>Copy of the array, cast to a specified type.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code>(inplace)</td>
<td>Swap the bytes of the array elements</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code>(choices[,&nbsp;out,&nbsp;mode])</td>
<td>Use an index array to construct a new array from a set of choices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([min,&nbsp;max,&nbsp;out])</td>
<td>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>(condition[,&nbsp;axis,&nbsp;out])</td>
<td>Return selected slices of this array along given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>()</td>
<td>Complex-conjugate all elements.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code>()</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([order])</td>
<td>Return a copy of the array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative product of the elements along the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative sum of the elements along the given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code>([offset,&nbsp;axis1,&nbsp;axis2])</td>
<td>Return specified diagonals.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(b[,&nbsp;out])</td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code>(file)</td>
<td>Dump a pickle of the array to the specified file.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code>()</td>
<td>Returns the pickle of the array as a string.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code>(value)</td>
<td>Fill the array with a scalar value.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code>([order])</td>
<td>Return a copy of the array collapsed into one dimension.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code>(dtype[,&nbsp;offset])</td>
<td>Returns a field of the given array as a certain type.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>(*args)</td>
<td>Copy an element of an array to a standard Python scalar and return it.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code>(*args)</td>
<td>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code>([axis,&nbsp;out])</td>
<td>Return the maximum along a given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns the average of the array elements along given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the minimum along a given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code>([new_order])</td>
<td>Return the array with the same data viewed with a different byte order.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code>()</td>
<td>Return the indices of the elements that are non-zero.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Rearranges the elements in the array in such a way that value of the element in kth position is in the position it would be in a sorted array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the product of the array elements over the given axis</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code>([axis,&nbsp;out])</td>
<td>Peak to peak (maximum - minimum) value along a given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code>(indices,&nbsp;values[,&nbsp;mode])</td>
<td>Set <code class="docutils literal notranslate"><span class="pre">a.flat[n]</span> <span class="pre">=</span> <span class="pre">values[n]</span></code> for all <cite>n</cite> in indices.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code>([order])</td>
<td>Return a flattened array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code>(repeats[,&nbsp;axis])</td>
<td>Repeat elements of an array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code>(shape[,&nbsp;order])</td>
<td>Returns an array containing the same data with a new shape.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code>(new_shape[,&nbsp;refcheck])</td>
<td>Change shape and size of array in-place.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code>([decimals,&nbsp;out])</td>
<td>Return <cite>a</cite> with each element rounded to the given number of decimals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.base.timeseries.timeseries.save" title="caiman.base.timeseries.timeseries.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(file_name[,&nbsp;to32,&nbsp;order,&nbsp;imagej,&nbsp;…])</td>
<td>Save the timeseries in various formats</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code>(v[,&nbsp;side,&nbsp;sorter])</td>
<td>Find indices where elements of v should be inserted in a to maintain order.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code>(val,&nbsp;dtype[,&nbsp;offset])</td>
<td>Put a value into a specified place in a field defined by a data-type.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code>([write,&nbsp;align,&nbsp;uic])</td>
<td>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code>([axis,&nbsp;kind,&nbsp;order])</td>
<td>Sort an array, in-place.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([axis])</td>
<td>Remove single-dimensional entries from the shape of <cite>a</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the standard deviation of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the sum of the array elements over the given axis.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code>(axis1,&nbsp;axis2)</td>
<td>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code>(indices[,&nbsp;axis,&nbsp;out,&nbsp;mode])</td>
<td>Return an array formed from the elements of <cite>a</cite> at the given indices.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code>([order])</td>
<td>Construct Python bytes containing the raw data bytes in the array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code>(fid[,&nbsp;sep,&nbsp;format])</td>
<td>Write array to a file as text or binary (default).</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code>()</td>
<td>Return the array as a (possibly nested) list.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code>([order])</td>
<td>Construct Python bytes containing the raw data bytes in the array.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([offset,&nbsp;axis1,&nbsp;axis2,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum along diagonals of the array.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code>(*axes)</td>
<td>Returns a view of the array with axes transposed.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the variance of the array elements, along given axis.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code>([dtype,&nbsp;type])</td>
<td>New view of array with the same data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.base.timeseries.timeseries.save">
<code class="descclassname">timeseries.</code><code class="descname">save</code><span class="sig-paren">(</span><em>file_name</em>, <em>to32=True</em>, <em>order='F'</em>, <em>imagej=False</em>, <em>bigtiff=True</em>, <em>software='CaImAn'</em>, <em>compress=0</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.timeseries.timeseries.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the timeseries in various formats</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_name: str</dt>
<dd>name of file. Possible formats are tif, avi, npz, mmap and hdf5</dd>
<dt>to32: Bool</dt>
<dd>whether to transform to 32 bits</dd>
<dt>order: ‘F’ or ‘C’</dt>
<dd>C or Fortran order</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>Exception ‘Extension Unknown’</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.base.timeseries.concatenate">
<code class="descclassname">caiman.base.timeseries.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.base.timeseries.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate movies</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mov: XMovie object</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="rois">
<h2>ROIs<a class="headerlink" href="#rois" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="parallel-processing-functions">
<h2>Parallel Processing functions<a class="headerlink" href="#parallel-processing-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.cluster.apply_to_patch">
<code class="descclassname">caiman.cluster.</code><code class="descname">apply_to_patch</code><span class="sig-paren">(</span><em>mmap_file</em>, <em>shape</em>, <em>dview</em>, <em>rf</em>, <em>stride</em>, <em>function</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.cluster.apply_to_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>apply function to patches in parallel or not</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_name: string</dt>
<dd>full path to an npy file (2D, pixels x time) containing the movie</dd>
<dt>shape: tuple of three elements</dt>
<dd>dimensions of the original movie across y, x, and time</dd>
<dt>rf: int</dt>
<dd>half-size of the square patch in pixel</dd>
<dt>stride: int</dt>
<dd>amount of overlap between patches</dd>
<dt>dview: ipyparallel view on client</dt>
<dd>if None</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>results</dd>
<dt>Raises:</dt>
<dd>Exception ‘Something went wrong’</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.cluster.start_server">
<code class="descclassname">caiman.cluster.</code><code class="descname">start_server</code><span class="sig-paren">(</span><em>slurm_script=None</em>, <em>ipcluster='ipcluster'</em>, <em>ncpus=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.cluster.start_server" title="Permalink to this definition">¶</a></dt>
<dd><p>programmatically start the ipyparallel server</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ncpus: int</dt>
<dd>number of processors</dd>
<dt>ipcluster <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>ipcluster binary file name; requires 4 path separators on Windows. ipcluster=”C:\Anaconda2\Scripts\ipcluster.exe”
Default: “ipcluster”</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.cluster.stop_server">
<code class="descclassname">caiman.cluster.</code><code class="descname">stop_server</code><span class="sig-paren">(</span><em>ipcluster='ipcluster'</em>, <em>pdir=None</em>, <em>profile=None</em>, <em>dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.cluster.stop_server" title="Permalink to this definition">¶</a></dt>
<dd><p>programmatically stops the ipyparallel server</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ipcluster <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>ipcluster binary file name; requires 4 path separators on Windows
Default: “ipcluster”</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="memory-mapping">
<h2>Memory mapping<a class="headerlink" href="#memory-mapping" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.mmapping.load_memmap">
<code class="descclassname">caiman.mmapping.</code><code class="descname">load_memmap</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='r'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.mmapping.load_memmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a memory mapped file created by the function save_memmap</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>path of the file to be loaded</dd>
<dt>mode: str</dt>
<dd>One of ‘r’, ‘r+’, ‘w+’. How to interact with files</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Yr:</dt>
<dd>memory mapped variable</dd>
<dt>dims: tuple</dt>
<dd>frame dimensions</dd>
<dt>T: int</dt>
<dd>number of frames</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>Exception “Unknown file extension”</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.mmapping.save_memmap_join">
<code class="descclassname">caiman.mmapping.</code><code class="descname">save_memmap_join</code><span class="sig-paren">(</span><em>mmap_fnames</em>, <em>base_name=None</em>, <em>n_chunks=20</em>, <em>dview=None</em>, <em>add_to_mov=0</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.mmapping.save_memmap_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a large file memmap from a number of smaller files</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mmap_fnames: list of memory mapped files</p>
<p>base_name: string, will be the first portion of name to be solved</p>
<p>n_chunks: number of chunks in which to subdivide when saving, smaller requires more memory</p>
<p class="last">dview: cluster handle</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.mmapping.save_memmap">
<code class="descclassname">caiman.mmapping.</code><code class="descname">save_memmap</code><span class="sig-paren">(</span><em>filenames</em>, <em>base_name='Yr'</em>, <em>resize_fact=(1</em>, <em>1</em>, <em>1)</em>, <em>remove_init=0</em>, <em>idx_xy=None</em>, <em>order='F'</em>, <em>xy_shifts=None</em>, <em>is_3D=False</em>, <em>add_to_movie=0</em>, <em>border_to_0=0</em>, <em>dview=None</em>, <em>n_chunks=100</em>, <em>slices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.mmapping.save_memmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently write data from a list of tif files into a memory mappable file</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>filenames: list</dt>
<dd>list of tif files or list of numpy arrays</dd>
<dt>base_name: str</dt>
<dd>the base used to build the file name. IT MUST NOT CONTAIN “_”</dd>
<dt>resize_fact: tuple</dt>
<dd>x,y, and z downsampling factors (0.5 means downsampled by a factor 2)</dd>
<dt>remove_init: int</dt>
<dd>number of frames to remove at the begining of each tif file
(used for resonant scanning images if laser in rutned on trial by trial)</dd>
<dt>idx_xy: tuple size 2 [or 3 for 3D data]</dt>
<dd>for selecting slices of the original FOV, for instance
idx_xy = (slice(150,350,None), slice(150,350,None))</dd>
<dt>order: string</dt>
<dd>whether to save the file in ‘C’ or ‘F’ order</dd>
<dt>xy_shifts: list</dt>
<dd>x and y shifts computed by a motion correction algorithm to be applied before memory mapping</dd>
<dt>is_3D: boolean</dt>
<dd>whether it is 3D data</dd>
<dt>add_to_movie: floating-point</dt>
<dd>value to add to each image point, typically to keep negative values out.</dd>
</dl>
<p>border_to_0: (undocumented)</p>
<p>dview:       (undocumented)</p>
<p>n_chunks:    (undocumented)</p>
<dl class="last docutils">
<dt>slices: slice object or list of slice objects</dt>
<dd>slice can be used to select portion of the movies in time and x,y
directions. For instance 
slices = [slice(0,200),slice(0,100),slice(0,100)] will take 
the first 200 frames and the 100 pixels along x and y dimensions.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>fname_new: the name of the mapped file, the format is such that</dt>
<dd>the name will contain the frame dimensions and the number of frames</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="image-statistics">
<h2>Image statistics<a class="headerlink" href="#image-statistics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.summary_images.local_correlations">
<code class="descclassname">caiman.summary_images.</code><code class="descname">local_correlations</code><span class="sig-paren">(</span><em>Y</em>, <em>eight_neighbours=True</em>, <em>swap_dim=True</em>, <em>order_mean=1</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.summary_images.local_correlations" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the correlation image for the input dataset Y</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y:  np.ndarray (3D or 4D)</dt>
<dd>Input movie data in 3D or 4D format</dd>
<dt>eight_neighbours: Boolean</dt>
<dd>Use 8 neighbors if true, and 4 if false for 3D data (default = True)
Use 6 neighbors for 4D data, irrespectively</dd>
<dt>swap_dim: Boolean</dt>
<dd>True indicates that time is listed in the last axis of Y (matlab format)
and moves it in the front</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>rho: d1 x d2 [x d3] matrix, cross-correlation with adjacent pixels</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.summary_images.max_correlation_image">
<code class="descclassname">caiman.summary_images.</code><code class="descname">max_correlation_image</code><span class="sig-paren">(</span><em>Y</em>, <em>bin_size=1000</em>, <em>eight_neighbours=True</em>, <em>swap_dim=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.summary_images.max_correlation_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the max-correlation image for the input dataset Y with bin_size</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y:  np.ndarray (3D or 4D)</dt>
<dd>Input movie data in 3D or 4D format</dd>
<dt>bin_size: scalar (integer)</dt>
<dd>Length of bin_size (if last bin is smaller than bin_size &lt; 2 bin_size is increased to impose uniform bins)</dd>
<dt>eight_neighbours: Boolean</dt>
<dd>Use 8 neighbors if true, and 4 if false for 3D data (default = True)
Use 6 neighbors for 4D data, irrespectively</dd>
<dt>swap_dim: Boolean</dt>
<dd>True indicates that time is listed in the last axis of Y (matlab format)
and moves it in the front</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Cn: d1 x d2 [x d3] matrix,</dt>
<dd>max correlation image</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.summary_images.correlation_pnr">
<code class="descclassname">caiman.summary_images.</code><code class="descname">correlation_pnr</code><span class="sig-paren">(</span><em>Y</em>, <em>gSig=None</em>, <em>center_psf=True</em>, <em>swap_dim=True</em>, <em>background_filter='disk'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.summary_images.correlation_pnr" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the correlation image and the peak-to-noise ratio (PNR) image.
If gSig is provided, then spatially filtered the video.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y:  np.ndarray (3D or 4D).</dt>
<dd>Input movie data in 3D or 4D format</dd>
<dt>gSig:  scalar or vector.</dt>
<dd>gaussian width. If gSig == None, no spatial filtering</dd>
<dt>center_psf: Boolearn</dt>
<dd>True indicates subtracting the mean of the filtering kernel</dd>
<dt>swap_dim: Boolean</dt>
<dd>True indicates that time is listed in the last axis of Y (matlab format)
and moves it in the front</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>cn: np.ndarray (2D or 3D).</dt>
<dd>local correlation image of the spatially filtered (or not)
data</dd>
<dt>pnr: np.ndarray (2D or 3D).</dt>
<dd>peak-to-noise ratios of all pixels/voxels</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="motion-correction">
<h2>Motion Correction<a class="headerlink" href="#motion-correction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.motion_correction.MotionCorrect">
<em class="property">class </em><code class="descclassname">caiman.motion_correction.</code><code class="descname">MotionCorrect</code><span class="sig-paren">(</span><em>fname, min_mov=None, dview=None, max_shifts=(6, 6), niter_rig=1, splits_rig=14, num_splits_to_process_rig=None, strides=(96, 96), overlaps=(32, 32), splits_els=14, num_splits_to_process_els=[7, None], upsample_factor_grid=4, max_deviation_rigid=3, shifts_opencv=True, nonneg_movie=True, gSig_filt=None, use_cuda=False, border_nan=True, pw_rigid=False, num_frames_split=80</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>class implementing motion correction operations</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.apply_shifts_movie" title="caiman.motion_correction.MotionCorrect.apply_shifts_movie"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_shifts_movie</span></code></a>(fname[,&nbsp;rigid_shifts,&nbsp;…])</td>
<td>Applies shifts found by registering one file to a different file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct" title="caiman.motion_correction.MotionCorrect.motion_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct</span></code></a>([template,&nbsp;save_movie])</td>
<td>general function for performing all types of motion correction.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct_pwrigid" title="caiman.motion_correction.MotionCorrect.motion_correct_pwrigid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct_pwrigid</span></code></a>([save_movie,&nbsp;…])</td>
<td>Perform pw-rigid motion correction</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.motion_correction.MotionCorrect.motion_correct_rigid" title="caiman.motion_correction.MotionCorrect.motion_correct_rigid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">motion_correct_rigid</span></code></a>([template,&nbsp;save_movie])</td>
<td>Perform rigid motion correction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.motion_correct">
<code class="descclassname">MotionCorrect.</code><code class="descname">motion_correct</code><span class="sig-paren">(</span><em>template=None</em>, <em>save_movie=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.motion_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>general function for performing all types of motion correction. The
function will perform either rigid or piecewise rigid motion correction
depending on the attribute self.pw_rigid and will perform high pass
spatial filtering for determining the motion (used in 1p data) if the
attribute self.gSig_filt is not None. A template can be passed, and the
output can be saved as a memory mapped file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>template: nd.array, default: None</dt>
<dd>template provided by user for motion correction</dd>
<dt>save_movie: bool, default: False</dt>
<dd>flag for saving motion corrected file(s) as memory mapped file(s)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.motion_correct_rigid">
<code class="descclassname">MotionCorrect.</code><code class="descname">motion_correct_rigid</code><span class="sig-paren">(</span><em>template=None</em>, <em>save_movie=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.motion_correct_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform rigid motion correction</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>template: ndarray 2D</dt>
<dd>if known, one can pass a template to register the frames to</dd>
<dt>save_movie_rigid:Bool</dt>
<dd>save the movies vs just get the template</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self</dd>
<dt>Important Fields:</dt>
<dd><p class="first">self.fname_tot_rig: name of the mmap file saved</p>
<p>self.total_template_rig: template updated by iterating  over the chunks</p>
<p>self.templates_rig: list of templates. one for each chunk</p>
<p class="last">self.shifts_rig: shifts in x and y per frame</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.motion_correct_pwrigid">
<code class="descclassname">MotionCorrect.</code><code class="descname">motion_correct_pwrigid</code><span class="sig-paren">(</span><em>save_movie=True</em>, <em>template=None</em>, <em>show_template=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.motion_correct_pwrigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform pw-rigid motion correction</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>template: ndarray 2D</dt>
<dd>if known, one can pass a template to register the frames to</dd>
<dt>save_movie:Bool</dt>
<dd>save the movies vs just get the template</dd>
<dt>show_template: boolean</dt>
<dd>whether to show the updated template at each iteration</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self</dd>
<dt>Important Fields:</dt>
<dd>self.fname_tot_els: name of the mmap file saved
self.templates_els: template updated by iterating  over the chunks
self.x_shifts_els: shifts in x per frame per patch
self.y_shifts_els: shifts in y per frame per patch
self.coord_shifts_els: coordinates associated to the patch for
values in x_shifts_els and y_shifts_els
self.total_template_els: list of templates. one for each chunk</dd>
<dt>Raises:</dt>
<dd>Exception: ‘Error: Template contains NaNs, Please review the parameters’</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.motion_correction.MotionCorrect.apply_shifts_movie">
<code class="descclassname">MotionCorrect.</code><code class="descname">apply_shifts_movie</code><span class="sig-paren">(</span><em>fname</em>, <em>rigid_shifts=True</em>, <em>border_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.MotionCorrect.apply_shifts_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies shifts found by registering one file to a different file. Useful
for cases when shifts computed from a structural channel are applied to a
functional channel. Currently only application of shifts through openCV is
supported.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>fname: str</dt>
<dd>name of the movie to motion correct. It should not contain nans. All the loadable formats from CaImAn are acceptable</dd>
<dt>rigid_shifts: bool</dt>
<dd>apply rigid or pw-rigid shifts (must exist in the mc object)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>m_reg: caiman movie object</dt>
<dd>caiman movie object with applied shifts (not memory mapped)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.motion_correction.motion_correct_oneP_rigid">
<code class="descclassname">caiman.motion_correction.</code><code class="descname">motion_correct_oneP_rigid</code><span class="sig-paren">(</span><em>filename</em>, <em>gSig_filt</em>, <em>max_shifts</em>, <em>dview=None</em>, <em>splits_rig=10</em>, <em>save_movie=True</em>, <em>border_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.motion_correct_oneP_rigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform rigid motion correction on one photon imaging movies</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>name of the file to correct</dd>
<dt>gSig_filt:</dt>
<dd>size of the filter. If algorithm does not work change this parameters</dd>
<dt>max_shifts: tuple of ints</dt>
<dd>max shifts in x and y allowed</dd>
<dt>dview:</dt>
<dd>handle to cluster</dd>
<dt>splits_rig: int</dt>
<dd>number of chunks for parallelizing motion correction (remember that it should hold that length_movie/num_splits_to_process_rig&gt;100)</dd>
<dt>save_movie: bool</dt>
<dd>whether to save the movie in memory mapped format</dd>
<dt>border_nan <span class="classifier-delimiter">:</span> <span class="classifier">bool or string, optional</span></dt>
<dd>Specifies how to deal with borders. (True, False, ‘copy’, ‘min’)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Motion correction object</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.motion_correction.motion_correct_oneP_nonrigid">
<code class="descclassname">caiman.motion_correction.</code><code class="descname">motion_correct_oneP_nonrigid</code><span class="sig-paren">(</span><em>filename</em>, <em>gSig_filt</em>, <em>max_shifts</em>, <em>strides</em>, <em>overlaps</em>, <em>splits_els</em>, <em>upsample_factor_grid</em>, <em>max_deviation_rigid</em>, <em>dview=None</em>, <em>splits_rig=10</em>, <em>save_movie=True</em>, <em>new_templ=None</em>, <em>border_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.motion_correction.motion_correct_oneP_nonrigid" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform rigid motion correction on one photon imaging movies</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>name of the file to correct</dd>
<dt>gSig_filt:</dt>
<dd>size of the filter. If algorithm does not work change this parameters</dd>
<dt>max_shifts: tuple of ints</dt>
<dd>max shifts in x and y allowed</dd>
<dt>dview:</dt>
<dd>handle to cluster</dd>
<dt>splits_rig: int</dt>
<dd>number of chunks for parallelizing motion correction (remember that it should hold that length_movie/num_splits_to_process_rig&gt;100)</dd>
<dt>save_movie: bool</dt>
<dd>whether to save the movie in memory mapped format</dd>
<dt>border_nan <span class="classifier-delimiter">:</span> <span class="classifier">bool or string, optional</span></dt>
<dd>specifies how to deal with borders. (True, False, ‘copy’, ‘min’)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Motion correction object</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="estimates">
<h2>Estimates<a class="headerlink" href="#estimates" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates">
<em class="property">class </em><code class="descclassname">caiman.source_extraction.cnmf.estimates.</code><code class="descname">Estimates</code><span class="sig-paren">(</span><em>A=None</em>, <em>b=None</em>, <em>C=None</em>, <em>f=None</em>, <em>R=None</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals" title="caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residuals</span></code></a>(Yr)</td>
<td>compute residual for each component (variable R)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f" title="caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_df_f</span></code></a>([quantileMin,&nbsp;frames_window,&nbsp;…])</td>
<td>Computes DF/F normalized fluorescence for the extracted traces.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components" title="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_components</span></code></a>(imgs,&nbsp;params[,&nbsp;dview])</td>
<td>Computes the quality metrics for each component and stores the indeces of the components that pass user specified thresholds.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN" title="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">evaluate_components_CNN</span></code></a>(params[,&nbsp;neuron_class])</td>
<td>Estimates the quality of inferred spatial components using a pretrained CNN classifier.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.filter_components" title="caiman.source_extraction.cnmf.estimates.Estimates.filter_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_components</span></code></a>(imgs,&nbsp;**kwargs)</td>
<td>Filters components based on given thresholds without re-computing the quality metrics.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components" title="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_view_components</span></code></a>([Yr,&nbsp;img,&nbsp;idx,&nbsp;…])</td>
<td>view spatial and temporal components interactively in a notebook</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d" title="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nb_view_components_3d</span></code></a>([Yr,&nbsp;image_type,&nbsp;…])</td>
<td>view spatial and temporal components interactively in a notebook (version for 3d data)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.normalize_components" title="caiman.source_extraction.cnmf.estimates.Estimates.normalize_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_components</span></code></a>()</td>
<td>Normalizes components such that spatial components have l_2 norm 1</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.play_movie" title="caiman.source_extraction.cnmf.estimates.Estimates.play_movie"><code class="xref py py-obj docutils literal notranslate"><span class="pre">play_movie</span></code></a>(imgs[,&nbsp;q_max,&nbsp;q_min,&nbsp;gain_res,&nbsp;…])</td>
<td>Displays a movie with three panels (original data (left panel), reconstructed data (middle panel), residual (right panel))</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours" title="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_contours</span></code></a>([img,&nbsp;idx,&nbsp;crd,&nbsp;thr_method,&nbsp;thr])</td>
<td>view contours of all spatial footprints.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb" title="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_contours_nb</span></code></a>([img,&nbsp;idx,&nbsp;crd,&nbsp;…])</td>
<td>view contours of all spatial footprints (notebook environment).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates" title="caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicates</span></code></a>([predictions,&nbsp;r_values,&nbsp;…])</td>
<td>remove neurons that heavily overlapand might be duplicates</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_small_large_neurons</span></code>(min_size_neuro,&nbsp;…)</td>
<td>remove neurons that are too large or too small</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.select_components" title="caiman.source_extraction.cnmf.estimates.Estimates.select_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_components</span></code></a>([idx_components,&nbsp;use_object])</td>
<td>Keeps only a selected subset of components and removes the rest.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_spatial_components</span></code>([maxthr,&nbsp;dview])</td>
<td>threshold spatial components.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.estimates.Estimates.view_components" title="caiman.source_extraction.cnmf.estimates.Estimates.view_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_components</span></code></a>([Yr,&nbsp;img,&nbsp;idx])</td>
<td>view spatial and temporal components interactively</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="30%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>masks_2_neurofinder</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals">
<code class="descclassname">Estimates.</code><code class="descname">compute_residuals</code><span class="sig-paren">(</span><em>Yr</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.compute_residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>compute residual for each component (variable R)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Yr <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>movie in format pixels (d) x frames (T)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f">
<code class="descclassname">Estimates.</code><code class="descname">detrend_df_f</code><span class="sig-paren">(</span><em>quantileMin=8</em>, <em>frames_window=500</em>, <em>flag_auto=True</em>, <em>use_fast=False</em>, <em>use_residuals=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.detrend_df_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes DF/F normalized fluorescence for the extracted traces. See
caiman.source.extraction.utilities.detrend_df_f for details</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>quantile_min: float</dt>
<dd>quantile used to estimate the baseline (values in [0,100])</dd>
<dt>frames_window: int</dt>
<dd>number of frames for computing running quantile</dd>
<dt>flag_auto: bool</dt>
<dd>flag for determining quantile automatically (different for each
trace)</dd>
<dt>use_fast: bool</dt>
<dd>flag for using approximate fast percentile filtering</dd>
<dt>use_residuals: bool</dt>
<dd>flag for using non-deconvolved traces in DF/F calculation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>self: CNMF object</dt>
<dd>self.F_dff contains the DF/F normalized traces</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components">
<code class="descclassname">Estimates.</code><code class="descname">evaluate_components</code><span class="sig-paren">(</span><em>imgs</em>, <em>params</em>, <em>dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the quality metrics for each component and stores the
indeces of the components that pass user specified thresholds. The
various thresholds and parameters can be passed as inputs. If left
empty then they are read from self.params.quality’]</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>imgs: np.array (possibly memory mapped, t,x,y[,z])</dt>
<dd>Imaging data</dd>
<dt>fr: float</dt>
<dd>Imaging rate</dd>
<dt>decay_time: float</dt>
<dd>length of decay of typical transient (in seconds)</dd>
<dt>min_SNR: float</dt>
<dd>trace SNR threshold</dd>
<dt>rval_thr: float</dt>
<dd>space correlation threshold</dd>
<dt>use_cnn: bool</dt>
<dd>flag for using the CNN classifier</dd>
<dt>min_cnn_thr: float</dt>
<dd>CNN classifier threshold</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>self: CNMF object</dt>
<dd><dl class="first last docutils">
<dt>self.idx_components: np.array</dt>
<dd>indeces of accepted components</dd>
<dt>self.idx_components_bad: np.array</dt>
<dd>indeces of rejected components</dd>
<dt>self.SNR_comp: np.array</dt>
<dd>SNR values for each temporal trace</dd>
<dt>self.r_values: np.array</dt>
<dd>space correlation values for each component</dd>
<dt>self.cnn_preds: np.array</dt>
<dd>CNN classifier values for each component</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN">
<code class="descclassname">Estimates.</code><code class="descname">evaluate_components_CNN</code><span class="sig-paren">(</span><em>params</em>, <em>neuron_class=1</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.evaluate_components_CNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the quality of inferred spatial components using a
pretrained CNN classifier.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>params: params object</dt>
<dd>see .params for details</dd>
<dt>neuron_class: int</dt>
<dd>class label for neuron shapes</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>self: Estimates object</dt>
<dd>self.idx_components contains the indeced of components above
the required treshold.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.filter_components">
<code class="descclassname">Estimates.</code><code class="descname">filter_components</code><span class="sig-paren">(</span><em>imgs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.filter_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters components based on given thresholds without re-computing
the quality metrics. If the quality metrics are not present then it
calls self.evaluate components.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>imgs: np.array (possibly memory mapped, t,x,y[,z])</dt>
<dd>Imaging data</dd>
<dt>fr: float</dt>
<dd>Imaging rate</dd>
<dt>decay_time: float</dt>
<dd>length of decay of typical transient (in seconds)</dd>
<dt>min_SNR: float</dt>
<dd>trace SNR threshold</dd>
<dt>SNR_lowest: float</dt>
<dd>minimum required trace SNR</dd>
<dt>rval_thr: float</dt>
<dd>space correlation threshold</dd>
<dt>rval_lowest: float</dt>
<dd>minimum required space correlation</dd>
<dt>use_cnn: bool</dt>
<dd>flag for using the CNN classifier</dd>
<dt>min_cnn_thr: float</dt>
<dd>CNN classifier threshold</dd>
<dt>cnn_lowest: float</dt>
<dd>minimum required CNN threshold</dd>
<dt>gSig_range: list</dt>
<dd>gSig scale values for CNN classifier</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>self: CNMF object</dt>
<dd><dl class="first last docutils">
<dt>self.idx_components: np.array</dt>
<dd>indeces of accepted components</dd>
<dt>self.idx_components_bad: np.array</dt>
<dd>indeces of rejected components</dd>
<dt>self.SNR_comp: np.array</dt>
<dd>SNR values for each temporal trace</dd>
<dt>self.r_values: np.array</dt>
<dd>space correlation values for each component</dd>
<dt>self.cnn_preds: np.array</dt>
<dd>CNN classifier values for each component</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components">
<code class="descclassname">Estimates.</code><code class="descname">nb_view_components</code><span class="sig-paren">(</span><em>Yr=None</em>, <em>img=None</em>, <em>idx=None</em>, <em>denoised_color=None</em>, <em>cmap='jet'</em>, <em>thr=0.99</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components" title="Permalink to this definition">¶</a></dt>
<dd><p>view spatial and temporal components interactively in a notebook</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Yr <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>movie in format pixels (d) x frames (T)</dd>
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</dd>
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of components to be plotted</dd>
<dt>thr: double</dt>
<dd>threshold regulating the extent of the displayed patches</dd>
<dt>denoised_color: string or None</dt>
<dd>color name (e.g. ‘red’) or hex color code (e.g. ‘#F0027F’)</dd>
<dt>cmap: string</dt>
<dd>name of colormap (e.g. ‘viridis’) used to plot image_neurons</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d">
<code class="descclassname">Estimates.</code><code class="descname">nb_view_components_3d</code><span class="sig-paren">(</span><em>Yr=None</em>, <em>image_type='mean'</em>, <em>dims=None</em>, <em>max_projection=False</em>, <em>axis=0</em>, <em>denoised_color=None</em>, <em>cmap='jet'</em>, <em>thr=0.9</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.nb_view_components_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>view spatial and temporal components interactively in a notebook
(version for 3d data)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Yr <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>movie in format pixels (d) x frames (T) (only required to
compute the correlation image)</dd>
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</dd>
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of components to be plotted</dd>
<dt>dims: tuple of ints</dt>
<dd>dimensions of movie (x, y and z)</dd>
<dt>image_type: ‘mean’|’max’|’corr’</dt>
<dd>image to be overlaid to neurons (average of shapes,
maximum of shapes or nearest neigbor correlation of raw data)</dd>
<dt>max_projection: bool</dt>
<dd>plot max projection along specified axis if True, o/w plot layers</dd>
<dt>axis: int (0, 1 or 2)</dt>
<dd>axis along which max projection is performed or layers are shown</dd>
<dt>thr: scalar between 0 and 1</dt>
<dd>Energy threshold for computing contours</dd>
<dt>denoised_color: string or None</dt>
<dd>color name (e.g. ‘red’) or hex color code (e.g. ‘#F0027F’)</dd>
<dt>cmap: string</dt>
<dd>name of colormap (e.g. ‘viridis’) used to plot image_neurons</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.normalize_components">
<code class="descclassname">Estimates.</code><code class="descname">normalize_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.normalize_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes components such that spatial components have l_2 norm 1</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.play_movie">
<code class="descclassname">Estimates.</code><code class="descname">play_movie</code><span class="sig-paren">(</span><em>imgs</em>, <em>q_max=99.75</em>, <em>q_min=2</em>, <em>gain_res=1</em>, <em>magnification=1</em>, <em>include_bck=True</em>, <em>frame_range=slice(None</em>, <em>None</em>, <em>None)</em>, <em>bpx=0</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.play_movie" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays a movie with three panels (original data (left panel),
reconstructed data (middle panel), residual (right panel))</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>imgs: np.array (possibly memory mapped, t,x,y[,z])</dt>
<dd>Imaging data</dd>
<dt>q_max: float (values in [0, 100])</dt>
<dd>percentile for maximum plotting value</dd>
<dt>q_min: float (values in [0, 100])</dt>
<dd>percentile for minimum plotting value</dd>
<dt>gain_res: float</dt>
<dd>amplification factor for residual movie</dd>
<dt>magnification: float</dt>
<dd>magnification factor for whole movie</dd>
<dt>include_bck: bool</dt>
<dd>flag for including background in original and reconstructed movie</dd>
<dt>frame_rage: range or slice or list</dt>
<dd>display only a subset of frames</dd>
<dt>bpx: int</dt>
<dd>number of pixels to exclude on each border</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self (to stop the movie press ‘q’)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours">
<code class="descclassname">Estimates.</code><code class="descname">plot_contours</code><span class="sig-paren">(</span><em>img=None</em>, <em>idx=None</em>, <em>crd=None</em>, <em>thr_method='max'</em>, <em>thr='0.2'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>view contours of all spatial footprints.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</dd>
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of accepted components</dd>
<dt>crd <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of coordinates (if empty they are computed)</dd>
<dt>thr_method <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>thresholding method for computing contours (‘max’, ‘nrg’)</dd>
<dt>thr <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>threshold value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb">
<code class="descclassname">Estimates.</code><code class="descname">plot_contours_nb</code><span class="sig-paren">(</span><em>img=None</em>, <em>idx=None</em>, <em>crd=None</em>, <em>thr_method='max'</em>, <em>thr='0.2'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.plot_contours_nb" title="Permalink to this definition">¶</a></dt>
<dd><p>view contours of all spatial footprints (notebook environment).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</dd>
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of accepted components</dd>
<dt>crd <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of coordinates (if empty they are computed)</dd>
<dt>thr_method <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>thresholding method for computing contours (‘max’, ‘nrg’)</dd>
<dt>thr <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>threshold value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates">
<code class="descclassname">Estimates.</code><code class="descname">remove_duplicates</code><span class="sig-paren">(</span><em>predictions=None</em>, <em>r_values=None</em>, <em>dist_thr=0.1</em>, <em>min_dist=10</em>, <em>thresh_subset=0.6</em>, <em>plot_duplicates=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.remove_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>remove neurons that heavily overlapand might be duplicates</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>predictions
r_values
dist_thr
min_dist
thresh_subset
plot_duplicates</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.select_components">
<code class="descclassname">Estimates.</code><code class="descname">select_components</code><span class="sig-paren">(</span><em>idx_components=None</em>, <em>use_object=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.select_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Keeps only a selected subset of components and removes the rest.
The subset can be either user defined with the variable idx_components
or read from the estimates object. The flag use_object determines this
choice. If no subset is present then all components are kept.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>idx_components: list</dt>
<dd>indeces of components to be kept</dd>
<dt>use_object: bool</dt>
<dd>Flag to use self.idx_components for reading the indeces.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self: Estimates object</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.estimates.Estimates.view_components">
<code class="descclassname">Estimates.</code><code class="descname">view_components</code><span class="sig-paren">(</span><em>Yr=None</em>, <em>img=None</em>, <em>idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.estimates.Estimates.view_components" title="Permalink to this definition">¶</a></dt>
<dd><p>view spatial and temporal components interactively</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Yr <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>movie in format pixels (d) x frames (T)</dd>
<dt>img <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd>background image for contour plotting. Default is the mean
image of all spatial components (d1 x d2)</dd>
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list of components to be plotted</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="deconvolution">
<h2>Deconvolution<a class="headerlink" href="#deconvolution" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.deconvolution.constrained_foopsi">
<code class="descclassname">caiman.source_extraction.cnmf.deconvolution.</code><code class="descname">constrained_foopsi</code><span class="sig-paren">(</span><em>fluor, bl=None, c1=None, g=None, sn=None, p=None, method_deconvolution='oasis', bas_nonneg=True, noise_range=[0.25, 0.5], noise_method='logmexp', lags=5, fudge_factor=1.0, verbosity=False, solvers=None, optimize_g=0, s_min=None, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.deconvolution.constrained_foopsi" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer the most likely discretized spike train underlying a fluorescence trace</p>
<p>It relies on a noise constrained deconvolution approach</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>fluor: np.ndarray</dt>
<dd>One dimensional array containing the fluorescence intensities with
one entry per time-bin.</dd>
<dt>bl: [optional] float</dt>
<dd>Fluorescence baseline value. If no value is given, then bl is estimated
from the data.</dd>
<dt>c1: [optional] float</dt>
<dd>value of calcium at time 0</dd>
<dt>g: [optional] list,float</dt>
<dd>Parameters of the AR process that models the fluorescence impulse response.
Estimated from the data if no value is given</dd>
<dt>sn: float, optional</dt>
<dd>Standard deviation of the noise distribution.  If no value is given,
then sn is estimated from the data.</dd>
<dt>p: int</dt>
<dd>order of the autoregression model</dd>
<dt>method_deconvolution: [optional] string</dt>
<dd>solution method for basis projection pursuit ‘cvx’ or ‘cvxpy’ or ‘oasis’</dd>
<dt>bas_nonneg: bool</dt>
<dd>baseline strictly non-negative</dd>
<dt>noise_range:  list of two elms</dt>
<dd>frequency range for averaging noise PSD</dd>
<dt>noise_method: string</dt>
<dd>method of averaging noise PSD</dd>
<dt>lags: int</dt>
<dd>number of lags for estimating time constants</dd>
<dt>fudge_factor: float</dt>
<dd>fudge factor for reducing time constant bias</dd>
<dt>verbosity: bool</dt>
<dd>display optimization details</dd>
<dt>solvers: list string</dt>
<dd>primary and secondary (if problem unfeasible for approx solution) solvers
to be used with cvxpy, default is [‘ECOS’,’SCS’]</dd>
<dt>optimize_g <span class="classifier-delimiter">:</span> <span class="classifier">[optional] int, only applies to method ‘oasis’</span></dt>
<dd>Number of large, isolated events to consider for optimizing g.
If optimize_g=0 (default) the provided or estimated g is not further optimized.</dd>
<dt>s_min <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, only applies to method ‘oasis’</span></dt>
<dd>Minimal non-zero activity within each bin (minimal ‘spike size’).
For negative values the threshold is abs(s_min) * sn * sqrt(1-g)
If None (default) the standard L1 penalty is used
If 0 the threshold is determined automatically such that RSS &lt;= sn^2 T</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first docutils">
<dt>c: np.ndarray float</dt>
<dd>The inferred denoised fluorescence signal at each time-bin.</dd>
</dl>
<p>bl, c1, g, sn : As explained above</p>
<dl class="last docutils">
<dt>sp: ndarray of float</dt>
<dd>Discretized deconvolved neural activity (spikes)</dd>
<dt>lam: float</dt>
<dd>Regularization parameter</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><p class="first">Exception(“You must specify the value of p”)</p>
<p>Exception(‘OASIS is currently only implemented for p=1 and p=2’)</p>
<p class="last">Exception(‘Undefined Deconvolution Method’)</p>
</dd>
<dt>References:</dt>
<dd><ul class="first last simple">
<li>Pnevmatikakis et al. 2016. Neuron, in press, <a class="reference external" href="http://dx.doi.org/10.1016/j.neuron.2015.11.037">http://dx.doi.org/10.1016/j.neuron.2015.11.037</a></li>
<li>Machado et al. 2015. Cell 162(2):338-350</li>
</ul>
</dd>
</dl>
<p>image: docs/img/deconvolution.png
image: docs/img/evaluationcomponent.png</p>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.deconvolution.constrained_oasisAR2">
<code class="descclassname">caiman.source_extraction.cnmf.deconvolution.</code><code class="descname">constrained_oasisAR2</code><span class="sig-paren">(</span><em>y</em>, <em>g</em>, <em>sn</em>, <em>optimize_b=True</em>, <em>b_nonneg=True</em>, <em>optimize_g=0</em>, <em>decimate=5</em>, <em>shift=100</em>, <em>window=None</em>, <em>tol=1e-09</em>, <em>max_iter=1</em>, <em>penalty=1</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.deconvolution.constrained_oasisAR2" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer the most likely discretized spike train underlying an AR(2) fluorescence trace</p>
<p>Solves the noise constrained sparse non-negative deconvolution problem
min (s)_1 subject to (c-y)^2 = sn^2 T and s_t = c_t-g1 c_{t-1}-g2 c_{t-2} &gt;= 0</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">array of float</span></dt>
<dd>One dimensional array containing the fluorescence intensities (with baseline
already subtracted) with one entry per time-bin.</dd>
<dt>g <span class="classifier-delimiter">:</span> <span class="classifier">(float, float)</span></dt>
<dd>Parameters of the AR(2) process that models the fluorescence impulse response.</dd>
<dt>sn <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Standard deviation of the noise distribution.</dd>
<dt>optimize_b <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default True</span></dt>
<dd>Optimize baseline if True else it is set to 0, see y.</dd>
<dt>b_nonneg: bool, optional, default True</dt>
<dd>Enforce strictly non-negative baseline if True.</dd>
<dt>optimize_g <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default 0</span></dt>
<dd>Number of large, isolated events to consider for optimizing g.
No optimization if optimize_g=0.</dd>
<dt>decimate <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default 5</span></dt>
<dd>Decimation factor for estimating hyper-parameters faster on decimated data.</dd>
<dt>shift <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default 100</span></dt>
<dd>Number of frames by which to shift window from on run of NNLS to the next.</dd>
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default None (200 or larger dependend on g)</span></dt>
<dd>Window size.</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default 1e-9</span></dt>
<dd>Tolerance parameter.</dd>
<dt>max_iter <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default 1</span></dt>
<dd>Maximal number of iterations.</dd>
<dt>penalty <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default 1</span></dt>
<dd>Sparsity penalty. 1: min (s)_1  0: min (s)_0</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">array of float</span></dt>
<dd>The inferred denoised fluorescence signal at each time-bin.</dd>
<dt>s <span class="classifier-delimiter">:</span> <span class="classifier">array of float</span></dt>
<dd>Discretized deconvolved neural activity (spikes).</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Fluorescence baseline value.</dd>
<dt>(g1, g2) <span class="classifier-delimiter">:</span> <span class="classifier">tuple of float</span></dt>
<dd>Parameters of the AR(2) process that models the fluorescence impulse response.</dd>
<dt>lam <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Sparsity penalty parameter lambda of dual problem.</dd>
</dl>
</dd>
<dt>References:</dt>
<dd>Friedrich J and Paninski L, NIPS 2016
Friedrich J, Zhou P, and Paninski L, arXiv 2016</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="parameter-setting">
<h2>Parameter Setting<a class="headerlink" href="#parameter-setting" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams">
<em class="property">class </em><code class="descclassname">caiman.source_extraction.cnmf.params.</code><code class="descname">CNMFParams</code><span class="sig-paren">(</span><em>fnames=None, dims=None, dxy=(1, 1), border_pix=0, del_duplicates=False, low_rank_background=True, memory_fact=1, n_processes=1, nb_patch=1, p_ssub=2, p_tsub=2, remove_very_bad_comps=False, rf=None, stride=None, check_nan=True, n_pixels_per_process=None, k=30, alpha_snmf=1000.0, center_psf=False, gSig=[5, 5], gSiz=None, init_iter=2, method_init='greedy_roi', min_corr=0.85, min_pnr=20, gnb=1, normalize_init=True, options_local_NMF=None, ring_size_factor=1.5, rolling_length=100, rolling_sum=True, ssub=2, ssub_B=2, tsub=2, block_size=5000, num_blocks_per_run=20, update_background_components=True, method_deconvolution='oasis', p=2, s_min=None, do_merge=True, merge_thresh=0.8, decay_time=0.4, fr=30, min_SNR=2.5, rval_thr=0.8, N_samples_exceptionality=None, batch_update_suff_stat=False, expected_comps=500, max_comp_update_shape=inf, max_num_added=5, min_num_trial=5, minibatch_shape=100, minibatch_suff_stat=5, n_refit=0, num_times_comp_updated=inf, simultaneously=False, sniper_mode=False, test_both=False, thresh_CNN_noisy=0.5, thresh_fitness_delta=-50, thresh_fitness_raw=None, thresh_overlap=0.5, update_num_comps=True, use_dense=True, use_peak_max=True, only_init_patch=False, params_dict={}</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.params.CNMFParams.get" title="caiman.source_extraction.cnmf.params.CNMFParams.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(group,&nbsp;key)</td>
<td>Get a value for a given group and key.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.params.CNMFParams.get_group" title="caiman.source_extraction.cnmf.params.CNMFParams.get_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_group</span></code></a>(group)</td>
<td>Get the dictionary of key-value pairs for a group.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.params.CNMFParams.set" title="caiman.source_extraction.cnmf.params.CNMFParams.set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set</span></code></a>(group,&nbsp;val_dict[,&nbsp;set_if_not_exists])</td>
<td>Add key-value pairs to a group.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>change_params</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>to_dict</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.set">
<code class="descclassname">CNMFParams.</code><code class="descname">set</code><span class="sig-paren">(</span><em>group</em>, <em>val_dict</em>, <em>set_if_not_exists=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.set" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Add key-value pairs to a group. Existing key-value pairs will be overwritten</dt>
<dd>if specified in val_dict, but not deleted.</dd>
<dt>Args:</dt>
<dd>group: The name of the group.
val_dict: A dictionary with key-value pairs to be set for the group.
set_if_not_exists: Whether to set a key-value pair in a group if the key does not currently exist in the group.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.get">
<code class="descclassname">CNMFParams.</code><code class="descname">get</code><span class="sig-paren">(</span><em>group</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a value for a given group and key. Raises an exception if no such group/key combination exists.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>group: The name of the group.
key: The key for the property in the group of interest.</dd>
</dl>
<p>Returns: The value for the group/key combination.</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.get_group">
<code class="descclassname">CNMFParams.</code><code class="descname">get_group</code><span class="sig-paren">(</span><em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.get_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dictionary of key-value pairs for a group.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>group: The name of the group.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.params.CNMFParams.change_params">
<code class="descclassname">CNMFParams.</code><code class="descname">change_params</code><span class="sig-paren">(</span><em>params_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.params.CNMFParams.change_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cnmf">
<h2>CNMF<a class="headerlink" href="#cnmf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF">
<em class="property">class </em><code class="descclassname">caiman.source_extraction.cnmf.cnmf.</code><code class="descname">CNMF</code><span class="sig-paren">(</span><em>n_processes, k=5, gSig=[4, 4], gSiz=None, merge_thresh=0.8, p=2, dview=None, Ain=None, Cin=None, b_in=None, f_in=None, do_merge=True, ssub=2, tsub=2, p_ssub=1, p_tsub=1, method_init='greedy_roi', alpha_snmf=None, rf=None, stride=None, memory_fact=1, gnb=1, nb_patch=1, only_init_patch=False, method_deconvolution='oasis', n_pixels_per_process=4000, block_size=5000, num_blocks_per_run=20, check_nan=True, skip_refinement=False, normalize_init=True, options_local_NMF=None, minibatch_shape=100, minibatch_suff_stat=3, update_num_comps=True, rval_thr=0.9, thresh_fitness_delta=-20, thresh_fitness_raw=None, thresh_overlap=0.5, max_comp_update_shape=inf, num_times_comp_updated=inf, batch_update_suff_stat=False, s_min=None, remove_very_bad_comps=False, border_pix=0, low_rank_background=True, update_background_components=True, rolling_sum=True, rolling_length=100, min_corr=0.85, min_pnr=20, ring_size_factor=1.5, center_psf=False, use_dense=True, deconv_flag=True, simultaneously=False, n_refit=0, del_duplicates=False, N_samples_exceptionality=None, max_num_added=3, min_num_trial=2, thresh_CNN_noisy=0.5, fr=30, decay_time=0.4, min_SNR=2.5, ssub_B=2, init_iter=2, sniper_mode=False, use_peak_max=False, test_both=False, expected_comps=500, params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF" title="Permalink to this definition">¶</a></dt>
<dd><p>Source extraction using constrained non-negative matrix factorization.</p>
<p>The general class which is used to produce a factorization of the Y matrix being the video
it computes it using all the files inside of cnmf folder.
Its architecture is similar to the one of scikit-learn calling the function fit to run everything which is part
of the structure of the class</p>
<p>it is calling everyfunction from the cnmf folder
you can find out more at how the functions are called and how they are laid out at the ipython notebook</p>
<p>See Also:
&#64;url <a class="reference external" href="http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3">http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3</a>
.. image:: docs/img/quickintro.png
&#64;author andrea giovannucci</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints" title="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HALS4footprints</span></code></a>(Yr[,&nbsp;update_bck,&nbsp;num_iter])</td>
<td>Uses hierarchical alternating least squares to update shapes and background</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces" title="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HALS4traces</span></code></a>(Yr[,&nbsp;groups,&nbsp;use_groups,&nbsp;order,&nbsp;…])</td>
<td>Solves C, f = argmin_C ||Yr-AC-bf|| using block-coordinate decent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_residuals</span></code>(Yr)</td>
<td>compute residual for each component (variable YrA)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve" title="caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deconvolve</span></code></a>([p,&nbsp;method_deconvolution,&nbsp;…])</td>
<td>Performs deconvolution on already extracted traces using constrained foopsi.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit" title="caiman.source_extraction.cnmf.cnmf.CNMF.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(images[,&nbsp;indeces])</td>
<td>This method uses the cnmf algorithm to find sources in data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.initialize" title="caiman.source_extraction.cnmf.cnmf.CNMF.initialize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize</span></code></a>(Y,&nbsp;**kwargs)</td>
<td>Component initialization</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps" title="caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_comps</span></code></a>(Y[,&nbsp;mx,&nbsp;fast_merge])</td>
<td>merges components</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.refit" title="caiman.source_extraction.cnmf.cnmf.CNMF.refit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refit</span></code></a>(images[,&nbsp;dview])</td>
<td>Refits the data using CNMF initialized from a previous interation</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_components</span></code>(ind_rm)</td>
<td>remove a specified list of components from the OnACID CNMF object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.save" title="caiman.source_extraction.cnmf.cnmf.CNMF.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(filename)</td>
<td>save object in hdf5 file format</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial" title="caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_spatial</span></code></a>(Y[,&nbsp;use_init])</td>
<td>Updates spatial components</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal" title="caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_temporal</span></code></a>(Y[,&nbsp;use_init])</td>
<td>Updates temporal components</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>fit_file</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>preprocess</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.fit">
<code class="descclassname">CNMF.</code><code class="descname">fit</code><span class="sig-paren">(</span><em>images, indeces=[slice(None, None, None), slice(None, None, None)]</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses the cnmf algorithm to find sources in data.</p>
<p>it is calling everyfunction from the cnmf folder
you can find out more at how the functions are called and how they are laid out at the ipython notebook</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">images : mapped np.ndarray of shape (t,x,y[,z]) containing the images that vary over time.</p>
<p class="last">indeces: list of slice objects along dimensions (x,y[,z]) for processing only part of the FOV</p>
</dd>
<dt>Returns:</dt>
<dd>self: updated using the cnmf algorithm with C,A,S,b,f computed according to the given initial values</dd>
</dl>
<p>Raises:
Exception ‘You need to provide a memory mapped file as input if you use patches!!’</p>
<p>See Also:
..image::docs/img/quickintro.png</p>
<p><a class="reference external" href="http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3">http://www.cell.com/neuron/fulltext/S0896-6273(15)01084-3</a></p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.refit">
<code class="descclassname">CNMF.</code><code class="descname">refit</code><span class="sig-paren">(</span><em>images</em>, <em>dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.refit" title="Permalink to this definition">¶</a></dt>
<dd><p>Refits the data using CNMF initialized from a previous interation</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>images
dview</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>cnm</dt>
<dd>A new CNMF object</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.fit_file">
<code class="descclassname">CNMF.</code><code class="descname">fit_file</code><span class="sig-paren">(</span><em>motion_correct=False, indeces=[slice(None, None, None), slice(None, None, None)]</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.fit_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.save">
<code class="descclassname">CNMF.</code><code class="descname">save</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object in hdf5 file format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>path to the hdf5 file containing the saved object</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve">
<code class="descclassname">CNMF.</code><code class="descname">deconvolve</code><span class="sig-paren">(</span><em>p=None</em>, <em>method_deconvolution=None</em>, <em>bas_nonneg=None</em>, <em>noise_method=None</em>, <em>optimize_g=0</em>, <em>s_min=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.deconvolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs deconvolution on already extracted traces using
constrained foopsi.</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial">
<code class="descclassname">CNMF.</code><code class="descname">update_spatial</code><span class="sig-paren">(</span><em>Y</em>, <em>use_init=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_spatial" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates spatial components</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y:  np.array (d1*d2) x T</dt>
<dd>input data</dd>
<dt>use_init: bool</dt>
<dd>use Cin, f_in for computing A, b otherwise use C, f</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>self</dt>
<dd>modified values self.estimates.A, self.estimates.b possibly self.estimates.C, self.estimates.f</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal">
<code class="descclassname">CNMF.</code><code class="descname">update_temporal</code><span class="sig-paren">(</span><em>Y</em>, <em>use_init=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.update_temporal" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates temporal components</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y:  np.array (d1*d2) x T</dt>
<dd>input data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces">
<code class="descclassname">CNMF.</code><code class="descname">HALS4traces</code><span class="sig-paren">(</span><em>Yr</em>, <em>groups=None</em>, <em>use_groups=False</em>, <em>order=None</em>, <em>update_bck=True</em>, <em>bck_non_neg=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4traces" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves C, f = argmin_C ||Yr-AC-bf|| using block-coordinate decent.
Can use groups to update non-overlapping components in parallel or a
specified order.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Yr <span class="classifier-delimiter">:</span> <span class="classifier">np.array (possibly memory mapped, (x,y,[,z]) x t)</span></dt>
<dd>Imaging data reshaped in matrix format</dd>
<dt>groups <span class="classifier-delimiter">:</span> <span class="classifier">list of sets</span></dt>
<dd>grouped components to be updated simultaneously</dd>
<dt>use_groups <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>flag for using groups</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>Update components in that order (used if nonempty and groups=None)</dd>
<dt>update_bck <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Flag for updating temporal background components</dd>
<dt>bck_non_neg <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Require temporal background to be non-negative</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self (updated values for self.estimates.C, self.estimates.f, self.estimates.YrA)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints">
<code class="descclassname">CNMF.</code><code class="descname">HALS4footprints</code><span class="sig-paren">(</span><em>Yr</em>, <em>update_bck=True</em>, <em>num_iter=2</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.HALS4footprints" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses hierarchical alternating least squares to update shapes and
background</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Yr: np.array (possibly memory mapped, (x,y,[,z]) x t)</dt>
<dd>Imaging data reshaped in matrix format</dd>
<dt>update_bck: bool</dt>
<dd>flag for updating spatial background components</dd>
<dt>num_iter: int</dt>
<dd>number of iterations</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self (updated values for self.estimates.A and self.estimates.b)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps">
<code class="descclassname">CNMF.</code><code class="descname">merge_comps</code><span class="sig-paren">(</span><em>Y</em>, <em>mx=50</em>, <em>fast_merge=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.merge_comps" title="Permalink to this definition">¶</a></dt>
<dd><p>merges components</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.initialize">
<code class="descclassname">CNMF.</code><code class="descname">initialize</code><span class="sig-paren">(</span><em>Y</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Component initialization</p>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.cnmf.CNMF.preprocess">
<code class="descclassname">CNMF.</code><code class="descname">preprocess</code><span class="sig-paren">(</span><em>Yr</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.CNMF.preprocess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.cnmf.load_CNMF">
<code class="descclassname">caiman.source_extraction.cnmf.cnmf.</code><code class="descname">load_CNMF</code><span class="sig-paren">(</span><em>filename</em>, <em>n_processes=1</em>, <em>dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.cnmf.load_CNMF" title="Permalink to this definition">¶</a></dt>
<dd><p>load object saved with the CNMF save method</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>hdf5 file name containing the saved object</dd>
<dt>dview: multiprocessingor ipyparallel object</dt>
<dd>useful to set up parllelization in the objects</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="online-cnmf-onacid">
<h2>Online CNMF (OnACID)<a class="headerlink" href="#online-cnmf-onacid" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID">
<em class="property">class </em><code class="descclassname">caiman.source_extraction.cnmf.online_cnmf.</code><code class="descname">OnACID</code><span class="sig-paren">(</span><em>params=None</em>, <em>estimates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID" title="Permalink to this definition">¶</a></dt>
<dd><p>Source extraction of streaming data using online matrix factorization.
The class can be initialized by passing a “params” object for setting up
the relevant parameters and an “Estimates” object for setting an initial
state of the algorithm (optional)</p>
<dl class="docutils">
<dt>Methods:</dt>
<dd><dl class="first last docutils">
<dt>initialize_online: </dt>
<dd>Initialize the online algorithm using a provided method, and prepare
the online object</dd>
<dt>_prepare_object: </dt>
<dd>Prepare the online object given a set of estimates</dd>
<dt>fit_next:</dt>
<dd>Fit the algorithm on the next data frame</dd>
<dt>fit_online:</dt>
<dd>Run the entire online pipeline on a given list of files</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_next</span></code></a>(t,&nbsp;frame_in[,&nbsp;num_iters_hals])</td>
<td>This method fits the next frame using the online cnmf algorithm and updates the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_online</span></code></a>(**kwargs)</td>
<td>Implements the caiman online algorithm on the list of files fls.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.save" title="caiman.source_extraction.cnmf.online_cnmf.OnACID.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(filename)</td>
<td>save object in hdf5 file format</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="68%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>create_frame</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>initialize_online</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online">
<code class="descclassname">OnACID.</code><code class="descname">fit_online</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_online" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the caiman online algorithm on the list of files fls. The
files are taken in alpha numerical order and are assumed to each have
the same number of frames (except the last one that can be shorter).
Caiman online is initialized using the seeded or bare initialization
methods.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>fls: list</dt>
<dd>list of files to be processed</dd>
<dt>init_batch: int</dt>
<dd>number of frames to be processed during initialization</dd>
<dt>epochs: int</dt>
<dd>number of passes over the data</dd>
<dt>motion_correct: bool</dt>
<dd>flag for performing motion correction</dd>
<dt>kwargs: dict</dt>
<dd>additional parameters used to modify self.params.online’]
see options.[‘online’] for details</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>self (results of caiman online)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next">
<code class="descclassname">OnACID.</code><code class="descname">fit_next</code><span class="sig-paren">(</span><em>t</em>, <em>frame_in</em>, <em>num_iters_hals=3</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.fit_next" title="Permalink to this definition">¶</a></dt>
<dd><p>This method fits the next frame using the online cnmf algorithm and
updates the object.</p>
<dl class="docutils">
<dt>Args</dt>
<dd><dl class="first last docutils">
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>time measured in number of frames</dd>
<dt>frame_in <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>flattened array of shape (x * y [ * z],) containing the t-th image.</dd>
<dt>num_iters_hals: int, optional</dt>
<dd>maximal number of iterations for HALS (NNLS via blockCD)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.save">
<code class="descclassname">OnACID.</code><code class="descname">save</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.save" title="Permalink to this definition">¶</a></dt>
<dd><p>save object in hdf5 file format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>path to the hdf5 file containing the saved object</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="caiman.source_extraction.cnmf.online_cnmf.OnACID.initialize_online">
<code class="descclassname">OnACID.</code><code class="descname">initialize_online</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.OnACID.initialize_online" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.online_cnmf.load_OnlineCNMF">
<code class="descclassname">caiman.source_extraction.cnmf.online_cnmf.</code><code class="descname">load_OnlineCNMF</code><span class="sig-paren">(</span><em>filename</em>, <em>dview=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.online_cnmf.load_OnlineCNMF" title="Permalink to this definition">¶</a></dt>
<dd><p>load object saved with the CNMF save method</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename: str</dt>
<dd>hdf5 file name containing the saved object</dd>
<dt>dview: multiprocessingor ipyparallel object</dt>
<dd>useful to set up parllelization in the objects</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="preprocessing">
<h2>Preprocessing<a class="headerlink" href="#preprocessing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.pre_processing.preprocess_data">
<code class="descclassname">caiman.source_extraction.cnmf.pre_processing.</code><code class="descname">preprocess_data</code><span class="sig-paren">(</span><em>Y, sn=None, dview=None, n_pixels_per_process=100, noise_range=[0.25, 0.5], noise_method='logmexp', compute_g=False, p=2, lags=5, include_noise=False, pixels=None, max_num_samples_fft=3000, check_nan=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.pre_processing.preprocess_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the pre-processing operations described above.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y: ndarray</dt>
<dd>input movie (n_pixels x Time). Can be also memory mapped file.</dd>
<dt>n_processes: [optional] int</dt>
<dd>number of processes/threads to use concurrently</dd>
<dt>n_pixels_per_process: [optional] int</dt>
<dd>number of pixels to be simultaneously processed by each process</dd>
<dt>p: positive integer</dt>
<dd>order of AR process, default: 2</dd>
<dt>lags: positive integer</dt>
<dd>number of lags in the past to consider for determining time constants. Default 5</dd>
<dt>include_noise: Boolean</dt>
<dd>Flag to include pre-estimated noise value when determining time constants. Default: False</dd>
<dt>noise_range: np.ndarray [2 x 1] between 0 and 0.5</dt>
<dd>Range of frequencies compared to Nyquist rate over which the power spectrum is averaged
default: [0.25,0.5]</dd>
<dt>noise method: string</dt>
<dd>method of averaging the noise.
Choices:
‘mean’: Mean
‘median’: Median
‘logmexp’: Exponential of the mean of the logarithm of PSD (default)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Y: ndarray</dt>
<dd>movie preprocessed (n_pixels x Time). Can be also memory mapped file.</dd>
<dt>g:  np.ndarray (p x 1)</dt>
<dd>Discrete time constants</dd>
<dt>psx: ndarray</dt>
<dd>position of thoses pixels</dd>
<dt>sn_s: ndarray (memory mapped)</dt>
<dd>file where to store the results of computation.</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="initialization">
<h2>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.initialization.initialize_components">
<code class="descclassname">caiman.source_extraction.cnmf.initialization.</code><code class="descname">initialize_components</code><span class="sig-paren">(</span><em>Y, K=30, gSig=[5, 5], gSiz=None, ssub=1, tsub=1, nIter=5, maxIter=5, nb=1, kernel=None, use_hals=True, normalize_init=True, img=None, method_init='greedy_roi', max_iter_snmf=500, alpha_snmf=1000.0, sigma_smooth_snmf=(0.5, 0.5, 0.5), perc_baseline_snmf=20, options_local_NMF=None, rolling_sum=False, rolling_length=100, sn=None, options_total=None, min_corr=0.8, min_pnr=10, ring_size_factor=1.5, center_psf=False, ssub_B=2, init_iter=2, remove_baseline=True</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.initialization.initialize_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Initalize components</p>
<p>This method uses a greedy approach followed by hierarchical alternative least squares (HALS) NMF.
Optional use of spatio-temporal downsampling to boost speed.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y: np.ndarray</dt>
<dd>d1 x d2 [x d3] x T movie, raw data.</dd>
<dt>K: [optional] int</dt>
<dd>number of neurons to extract (default value: 30). Maximal number for method ‘corr_pnr’.</dd>
<dt>tau: [optional] list,tuple</dt>
<dd>standard deviation of neuron size along x and y [and z] (default value: (5,5).</dd>
<dt>gSiz: [optional] list,tuple</dt>
<dd>size of kernel (default 2*tau + 1).</dd>
<dt>nIter: [optional] int</dt>
<dd>number of iterations for shape tuning (default 5).</dd>
<dt>maxIter: [optional] int</dt>
<dd>number of iterations for HALS algorithm (default 5).</dd>
<dt>ssub: [optional] int</dt>
<dd>spatial downsampling factor recommended for large datasets (default 1, no downsampling).</dd>
<dt>tsub: [optional] int</dt>
<dd>temporal downsampling factor recommended for long datasets (default 1, no downsampling).</dd>
<dt>kernel: [optional] np.ndarray</dt>
<dd>User specified kernel for greedyROI
(default None, greedy ROI searches for Gaussian shaped neurons)</dd>
<dt>use_hals: [optional] bool</dt>
<dd>Whether to refine components with the hals method</dd>
<dt>normalize_init: [optional] bool</dt>
<dd>Whether to normalize_init data before running the initialization</dd>
<dt>img: optional [np 2d array]</dt>
<dd>Image with which to normalize. If not present use the mean + offset</dd>
<dt>method: str</dt>
<dd>Initialization method ‘greedy_roi’ or ‘sparse_nmf’</dd>
<dt>max_iter_snmf: int</dt>
<dd>Maximum number of sparse NMF iterations</dd>
<dt>alpha_snmf: scalar</dt>
<dd>Sparsity penalty</dd>
<dt>rolling_sum: boolean</dt>
<dd>Detect new components based on a rolling sum of pixel activity (default: True)</dd>
<dt>rolling_length: int</dt>
<dd>Length of rolling window (default: 100)</dd>
<dt>center_psf: Boolean</dt>
<dd>True indicates centering the filtering kernel for background
removal. This is useful for data with large background
fluctuations.</dd>
<dt>min_corr: float</dt>
<dd>minimum local correlation coefficients for selecting a seed pixel.</dd>
<dt>min_pnr: float</dt>
<dd>minimum peak-to-noise ratio for selecting a seed pixel.</dd>
<dt>ring_size_factor: float</dt>
<dd>it’s the ratio between the ring radius and neuron diameters.</dd>
<dt>nb: integer</dt>
<dd>number of background components for approximating the background using NMF model</dd>
<dt>sn: ndarray</dt>
<dd>per pixel noise</dd>
<dt>options_total: dict</dt>
<dd>the option dictionary</dd>
<dt>ssub_B: int, optional</dt>
<dd>downsampling factor for 1-photon imaging background computation</dd>
<dt>init_iter: int, optional</dt>
<dd>number of iterations for 1-photon imaging initialization</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Ain: np.ndarray</dt>
<dd>(d1 * d2 [ * d3]) x K , spatial filter of each neuron.</dd>
<dt>Cin: np.ndarray</dt>
<dd>T x K , calcium activity of each neuron.</dd>
<dt>center: np.ndarray</dt>
<dd>K x 2 [or 3] , inferred center of each neuron.</dd>
<dt>bin: np.ndarray</dt>
<dd>(d1 * d2 [ * d3]) x nb, initialization of spatial background.</dd>
<dt>fin: np.ndarray</dt>
<dd>nb x T matrix, initalization of temporal background</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><p class="first">Exception “Unsupported method”</p>
<p class="last">Exception ‘You need to define arguments for local NMF’</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="spatial-components">
<h2>Spatial Components<a class="headerlink" href="#spatial-components" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.spatial.update_spatial_components">
<code class="descclassname">caiman.source_extraction.cnmf.spatial.</code><code class="descname">update_spatial_components</code><span class="sig-paren">(</span><em>Y, C=None, f=None, A_in=None, sn=None, dims=None, min_size=3, max_size=8, dist=3, normalize_yyt_one=True, method_exp='dilate', expandCore=None, dview=None, n_pixels_per_process=128, medw=(3, 3), thr_method='max', maxthr=0.1, nrgthr=0.9999, extract_cc=True, b_in=None, se=array([[1, 1, 1],        [1, 1, 1],        [1, 1, 1]]), ss=array([[1, 1, 1],        [1, 1, 1],        [1, 1, 1]]), nb=1, method_ls='lasso_lars', update_background_components=True, low_rank_background=True, block_size=1000, num_blocks_per_run=20</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.spatial.update_spatial_components" title="Permalink to this definition">¶</a></dt>
<dd><p>update spatial footprints and background through Basis Pursuit Denoising</p>
<dl class="docutils">
<dt>for each pixel i solve the problem</dt>
<dd>[A(i,:),b(i)] = argmin sum(A(i,:))</dd>
<dt>subject to</dt>
<dd>|| Y(i,:) - A(i,:)*C + b(i)*f || &lt;= sn(i)*sqrt(T);</dd>
</dl>
<p>for each pixel the search is limited to a few spatial components</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>Y: np.ndarray (2D or 3D)</dt>
<dd>movie, raw data in 2D or 3D (pixels x time).</dd>
<dt>C: np.ndarray</dt>
<dd>calcium activity of each neuron.</dd>
<dt>f: np.ndarray</dt>
<dd>temporal profile  of background activity.</dd>
<dt>A_in: np.ndarray</dt>
<dd>spatial profile of background activity. If A_in is boolean then it defines the spatial support of A.
Otherwise it is used to determine it through determine_search_location</dd>
<dt>b_in: np.ndarray</dt>
<dd>you can pass background as input, especially in the case of one background per patch, since it will update using hals</dd>
<dt>dims: [optional] tuple</dt>
<dd>x, y[, z] movie dimensions</dd>
</dl>
<p>min_size: [optional] int</p>
<p>max_size: [optional] int</p>
<p>dist: [optional] int</p>
<dl class="last docutils">
<dt>sn: [optional] float</dt>
<dd>noise associated with each pixel if known</dd>
<dt>backend [optional] str</dt>
<dd>‘ipyparallel’, ‘single_thread’
single_thread:no parallelization. It can be used with small datasets.
ipyparallel: uses ipython clusters and then send jobs to each of them
SLURM: use the slurm scheduler</dd>
<dt>n_pixels_per_process: [optional] int</dt>
<dd>number of pixels to be processed by each thread</dd>
<dt>method: [optional] string</dt>
<dd>method used to expand the search for pixels ‘ellipse’ or ‘dilate’</dd>
<dt>expandCore: [optional]  scipy.ndimage.morphology</dt>
<dd>if method is dilate this represents the kernel used for expansion</dd>
<dt>dview: view on ipyparallel client</dt>
<dd>you need to create an ipyparallel client and pass a view on the processors (client = Client(), dview=client[:])</dd>
<dt>medw, thr_method, maxthr, nrgthr, extract_cc, se, ss: [optional]</dt>
<dd>Parameters for components post-processing. Refer to spatial.threshold_components for more details</dd>
<dt>nb: [optional] int</dt>
<dd>Number of background components</dd>
<dt>method_ls:</dt>
<dd><dl class="first last docutils">
<dt>method to perform the regression for the basis pursuit denoising.</dt>
<dd>‘nnls_L0’. Nonnegative least square with L0 penalty
‘lasso_lars’ lasso lars function from scikit learn</dd>
<dt>normalize_yyt_one: bool</dt>
<dd>wheter to norrmalize the C and A matrices so that diag(C*C.T) are ones</dd>
</dl>
</dd>
<dt>update_background_components:bool</dt>
<dd>whether to update the background components in the spatial phase</dd>
<dt>low_rank_background:bool</dt>
<dd>whether to update the using a low rank approximation. In the False case all the nonzero elements of the background components are updated using hals
(to be used with one background per patch)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>A: np.ndarray</dt>
<dd>new estimate of spatial footprints</dd>
<dt>b: np.ndarray</dt>
<dd>new estimate of spatial background</dd>
<dt>C: np.ndarray</dt>
<dd>temporal components (updated only when spatial components are completely removed)</dd>
<dt>f: np.ndarray</dt>
<dd>same as f_in except if empty component deleted.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><p class="first">Exception ‘You need to define the input dimensions’</p>
<p>Exception ‘Dimension of Matrix Y must be pixels x time’</p>
<p>Exception ‘Dimension of Matrix C must be neurons x time’</p>
<p>Exception ‘Dimension of Matrix f must be background comps x time ‘</p>
<p>Exception ‘Either A or C need to be determined’</p>
<p>Exception ‘Dimension of Matrix A must be pixels x neurons’</p>
<p>Exception ‘You need to provide estimate of C and f’</p>
<p>Exception ‘Not implemented consistently’</p>
<p class="last">Exception “Failed to delete: ” + folder</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="temporal-components">
<h2>Temporal Components<a class="headerlink" href="#temporal-components" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.temporal.update_temporal_components">
<code class="descclassname">caiman.source_extraction.cnmf.temporal.</code><code class="descname">update_temporal_components</code><span class="sig-paren">(</span><em>Y</em>, <em>A</em>, <em>b</em>, <em>Cin</em>, <em>fin</em>, <em>bl=None</em>, <em>c1=None</em>, <em>g=None</em>, <em>sn=None</em>, <em>nb=1</em>, <em>ITER=2</em>, <em>block_size=5000</em>, <em>num_blocks_per_run=20</em>, <em>debug=False</em>, <em>dview=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.temporal.update_temporal_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Update temporal components and background given spatial components using a block coordinate descent approach.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y: np.ndarray (2D)</dt>
<dd>input data with time in the last axis (d x T)</dd>
<dt>A: sparse matrix (crc format)</dt>
<dd>matrix of temporal components (d x K)</dd>
<dt>b: ndarray (dx1)</dt>
<dd>current estimate of background component</dd>
<dt>Cin: np.ndarray</dt>
<dd>current estimate of temporal components (K x T)</dd>
<dt>fin: np.ndarray</dt>
<dd>current estimate of temporal background (vector of length T)</dd>
<dt>g:  np.ndarray</dt>
<dd>Global time constant (not used)</dd>
<dt>bl: np.ndarray</dt>
<dd>baseline for fluorescence trace for each column in A</dd>
<dt>c1: np.ndarray</dt>
<dd>initial concentration for each column in A</dd>
<dt>g:  np.ndarray</dt>
<dd>discrete time constant for each column in A</dd>
<dt>sn: np.ndarray</dt>
<dd>noise level for each column in A</dd>
<dt>nb: [optional] int</dt>
<dd>Number of background components</dd>
<dt>ITER: positive integer</dt>
<dd>Maximum number of block coordinate descent loops.</dd>
<dt>method_foopsi: string</dt>
<dd>Method of deconvolution of neural activity. constrained_foopsi is the only method supported at the moment.</dd>
<dt>n_processes: int</dt>
<dd><dl class="first last docutils">
<dt>number of processes to use for parallel computation.</dt>
<dd>Should be less than the number of processes started with ipcluster.</dd>
</dl>
</dd>
<dt>backend: ‘str’</dt>
<dd>single_thread no parallelization
ipyparallel, parallelization using the ipyparallel cluster.
You should start the cluster (install ipyparallel and then type
ipcluster -n 6, where 6 is the number of processes).
SLURM: using SLURM scheduler</dd>
<dt>memory_efficient: Bool</dt>
<dd>whether or not to optimize for memory usage (longer running times). necessary with very large datasets</dd>
<dt>kwargs: dict</dt>
<dd><dl class="first last docutils">
<dt>all parameters passed to constrained_foopsi except bl,c1,g,sn (see documentation).</dt>
<dd>Some useful parameters are</dd>
</dl>
</dd>
<dt>p: int</dt>
<dd>order of the autoregression model</dd>
<dt>method: [optional] string</dt>
<dd><dl class="first last docutils">
<dt>solution method for constrained foopsi. Choices are</dt>
<dd>‘cvx’:      using cvxopt and picos (slow especially without the MOSEK solver)
‘cvxpy’:    using cvxopt and cvxpy with the ECOS solver (faster, default)</dd>
</dl>
</dd>
<dt>solvers: list string</dt>
<dd><dl class="first last docutils">
<dt>primary and secondary (if problem unfeasible for approx solution)</dt>
<dd>solvers to be used with cvxpy, default is [‘ECOS’,’SCS’]</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>The temporal components are updated in parallel by default by forming of sequence of vertex covers.</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>C:   np.ndarray</dt>
<dd>matrix of temporal components (K x T)</dd>
<dt>f:   np.array</dt>
<dd>vector of temporal background (length T)</dd>
<dt>S:   np.ndarray</dt>
<dd>matrix of merged deconvolved activity (spikes) (K x T)</dd>
<dt>bl:  float</dt>
<dd>same as input</dd>
<dt>c1:  float</dt>
<dd>same as input</dd>
<dt>g:   float</dt>
<dd>same as input</dd>
<dt>sn:  float</dt>
<dd>same as input</dd>
<dt>YrA: np.ndarray</dt>
<dd>matrix of spatial component filtered raw data, after all contributions have been removed.
YrA corresponds to the residual trace for each component and is used for faster plotting (K x T)</dd>
<dt>lam: np.ndarray</dt>
<dd>Automatically tuned sparsity parameter</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="merge-components">
<h2>Merge components<a class="headerlink" href="#merge-components" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.merging.merge_components">
<code class="descclassname">caiman.source_extraction.cnmf.merging.</code><code class="descname">merge_components</code><span class="sig-paren">(</span><em>Y</em>, <em>A</em>, <em>b</em>, <em>C</em>, <em>f</em>, <em>S</em>, <em>sn_pix</em>, <em>temporal_params</em>, <em>spatial_params</em>, <em>dview=None</em>, <em>thr=0.85</em>, <em>fast_merge=True</em>, <em>mx=1000</em>, <em>bl=None</em>, <em>c1=None</em>, <em>sn=None</em>, <em>g=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.merging.merge_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Merging of spatially overlapping components that have highly correlated temporal activity</p>
<p>The correlation threshold for merging overlapping components is user specified in thr</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>Y: np.ndarray</dt>
<dd>residual movie after subtracting all found components (Y_res = Y - A*C - b*f) (d x T)</dd>
<dt>A: sparse matrix</dt>
<dd>matrix of spatial components (d x K)</dd>
<dt>b: np.ndarray</dt>
<dd>spatial background (vector of length d)</dd>
<dt>C: np.ndarray</dt>
<dd>matrix of temporal components (K x T)</dd>
<dt>f:     np.ndarray</dt>
<dd>temporal background (vector of length T)</dd>
<dt>S:     np.ndarray</dt>
<dd>matrix of deconvolved activity (spikes) (K x T)</dd>
<dt>sn_pix: ndarray</dt>
<dd>noise standard deviation for each pixel</dd>
<dt>temporal_params: dictionary</dt>
<dd>all the parameters that can be passed to the update_temporal_components function</dd>
<dt>spatial_params: dictionary</dt>
<dd>all the parameters that can be passed to the update_spatial_components function</dd>
<dt>thr:   scalar between 0 and 1</dt>
<dd>correlation threshold for merging (default 0.85)</dd>
<dt>mx:    int</dt>
<dd>maximum number of merging operations (default 50)</dd>
<dt>sn_pix:    nd.array</dt>
<dd>noise level for each pixel (vector of length d)</dd>
<dt>fast_merge: bool</dt>
<dd>if true perform rank 1 merging, otherwise takes best neuron</dd>
<dt>bl:</dt>
<dd>baseline for fluorescence trace for each row in C</dd>
<dt>c1:</dt>
<dd>initial concentration for each row in C</dd>
<dt>g:</dt>
<dd>discrete time constant for each row in C</dd>
<dt>sn:</dt>
<dd>noise level for each row in C</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>A:     sparse matrix</dt>
<dd>matrix of merged spatial components (d x K)</dd>
<dt>C:     np.ndarray</dt>
<dd>matrix of merged temporal components (K x T)</dd>
<dt>nr:    int</dt>
<dd>number of components after merging</dd>
<dt>merged_ROIs: list</dt>
<dd>index of components that have been merged</dd>
<dt>S:     np.ndarray</dt>
<dd>matrix of merged deconvolved activity (spikes) (K x T)</dd>
<dt>bl: float</dt>
<dd>baseline for fluorescence trace</dd>
<dt>c1: float</dt>
<dd>initial concentration</dd>
<dt>g:  float</dt>
<dd>discrete time constant</dd>
<dt>sn: float</dt>
<dd>noise level</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>Exception “The number of elements of blc1gsn must match the number of components”</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="caiman.source_extraction.cnmf.utilities.detrend_df_f_auto">
<code class="descclassname">caiman.source_extraction.cnmf.utilities.</code><code class="descname">detrend_df_f_auto</code><span class="sig-paren">(</span><em>A</em>, <em>b</em>, <em>C</em>, <em>f</em>, <em>dims=None</em>, <em>YrA=None</em>, <em>use_annulus=True</em>, <em>dist1=7</em>, <em>dist2=5</em>, <em>frames_window=1000</em>, <em>use_fast=False</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.utilities.detrend_df_f_auto" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute DF/F using an automated level of percentile filtering based on
kernel density estimation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>A: scipy.sparse.csc_matrix</dt>
<dd>spatial components (from cnmf cnm.A)</dd>
<dt>b: ndarray</dt>
<dd>spatial backgrounds</dd>
<dt>C: ndarray</dt>
<dd>temporal components (from cnmf cnm.C)</dd>
<dt>f: ndarray</dt>
<dd>temporal background components</dd>
<dt>YrA: ndarray</dt>
<dd>residual signals</dd>
<dt>frames_window: int</dt>
<dd>number of frames for running quantile</dd>
<dt>use_fast: bool</dt>
<dd>flag for using fast approximate percentile filtering</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>F_df:</dt>
<dd>the computed Calcium acitivty to the derivative of f</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.utilities.update_order">
<code class="descclassname">caiman.source_extraction.cnmf.utilities.</code><code class="descname">update_order</code><span class="sig-paren">(</span><em>A</em>, <em>new_a=None</em>, <em>prev_list=None</em>, <em>method='greedy'</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.utilities.update_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the update order of the temporal components given the spatial
components by creating a nest of random approximate vertex covers</p>
<blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>A:    np.ndarray</dt>
<dd>matrix of spatial components (d x K)</dd>
<dt>new_a: sparse array</dt>
<dd>spatial component that is added, in order to efficiently update the orders in online scenarios</dd>
<dt>prev_list: list of list</dt>
<dd>orders from previous iteration, you need to pass if new_a is not None</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>O:  list of sets</dt>
<dd>list of subsets of components. The components of each subset can be updated in parallel</dd>
<dt>lo: list</dt>
<dd>length of each subset</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Written by Eftychios A. Pnevmatikakis, Simons Foundation, 2015</p>
</dd></dl>

<dl class="function">
<dt id="caiman.source_extraction.cnmf.utilities.get_file_size">
<code class="descclassname">caiman.source_extraction.cnmf.utilities.</code><code class="descname">get_file_size</code><span class="sig-paren">(</span><em>file_name</em>, <em>var_name_hdf5=None</em><span class="sig-paren">)</span><a class="headerlink" href="#caiman.source_extraction.cnmf.utilities.get_file_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Core Functions</a><ul>
<li><a class="reference internal" href="#movie-handling">Movie Handling</a></li>
<li><a class="reference internal" href="#timeseries-handling">Timeseries Handling</a></li>
<li><a class="reference internal" href="#rois">ROIs</a></li>
<li><a class="reference internal" href="#parallel-processing-functions">Parallel Processing functions</a></li>
<li><a class="reference internal" href="#memory-mapping">Memory mapping</a></li>
<li><a class="reference internal" href="#image-statistics">Image statistics</a></li>
<li><a class="reference internal" href="#motion-correction">Motion Correction</a></li>
<li><a class="reference internal" href="#estimates">Estimates</a></li>
<li><a class="reference internal" href="#deconvolution">Deconvolution</a></li>
<li><a class="reference internal" href="#parameter-setting">Parameter Setting</a></li>
<li><a class="reference internal" href="#cnmf">CNMF</a></li>
<li><a class="reference internal" href="#online-cnmf-onacid">Online CNMF (OnACID)</a></li>
<li><a class="reference internal" href="#preprocessing">Preprocessing</a></li>
<li><a class="reference internal" href="#initialization">Initialization</a></li>
<li><a class="reference internal" href="#spatial-components">Spatial Components</a></li>
<li><a class="reference internal" href="#temporal-components">Temporal Components</a></li>
<li><a class="reference internal" href="#merge-components">Merge components</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Overview.html"
                        title="previous chapter">Overview</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/core_functions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Overview.html" title="Overview"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Constrained NMF 0.0.4 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Eftychios Pnevmatikakis and Andrea Giovannucci.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>